* remove ref counting of vertex buffers from gfx.Effect
* have KernelParamInterface return uniform/varying param data (data from the multi arrays,
	just packed together) plus a pointer to a pointer to the storage. so e.g. if the param
	is a float, the param interface must expose float**, so that the user of the param
	interface may set the pointer to the data that will be used by the effect
	-> bindings/connections of structure data to effect params, regardless of the names
		in the effect
	-> even if the user connects structure data directly to an input channel of some quark,
		the kernel compiler may decide to route it through conversion quark(s) first
	-> just one input per param - duplicates must be reduced in the compilation step


per-object material/structure props might be needed
undecided how to handle these; either by creating MaterialData per object or by having
	special params that are stored in the object. former harder to update when inherited
	material changes, latter introduce more mess
could go via manually defining the per-object params for materials and structure,
	specifying their defaults from within the editor, creating the default vals per object
	and having reflection data for the object. don't allow these to be created
	by the renderers, can then hold just one value shared between EffectInstances


params can be sourced from the material itself or from MaterialData (material instance).
	decided upon renderable compilation.


MeshAsset / LoaderMesh loads the data in the form of vec3[] arrays, etc
MeshStructureData creates and stores gfx-based VertexBuffers and attribs
MeshStructureData connected to Renderables upon compilation, the pointers created for
	EffectInstances connected to the internal storage in MeshStructureData
	* for varyings - one ptr for the vb, another for the attrib def, thus vb can be shared


----

+	change the gfx EffectInstance not to locally store params but have pointers
	to them instead
	+ uniforms
	+ varyings
	-> this will allow their storage in Renderables, however the old tests will be broken
		+ create a function to alloc and bind default storage to revive them
	* for now, screw updating of varyings. can later do some fancy shite if it's needed

+	implement MeshStructure
	+ creation of uniforms, vertex buffers and attribs
	+ binding of params to KernelDataInterface
	+ acquisition of stuff from the assets / xf.loader
	* no meta info yet

+	implement KernelDataInterface

+	hardcode VSD and test the hacked up Kernel-based rendering

~	fix VSD
	+ dumb sphere-based frustum culling
	- invalidation, enabling and disabling of objects
	- proper memory management
	* later - the hack works for now and has more than originally intended anyway :P

+	implement kernel graphs
	+ adding, removing, substituting nodes
	+ node connections with manual and automatic data flow
	+ topological sorting with peeling/layers
	+ unreachable flow trimming
	+ simplification

+	semantic type system
	+ Semantic class with good mem management
	+ Semantic comparison utils
	+ Param class with an easy accessor to the type
	+ Basic type parsing

+	automatic conversions
	+ testing whether a semantic can be used as an argument to a particular function param
	+ path-finding in the implicit graph of semantic types

+	revive the kernel/quark parser
	* only for Cg

+	do a semantic pass on parsed data and pack stuff into runtime structs

+	quark graph codegen into Cg
	* it is assumed that Structure and Surface kernels are merged before this stage
	+ mark nodes for various stages of processing
		+ have a special Rasterize node, mark everything before it for vertex
		+ the rest for fragment
			* will later move between stages via special quark annotations
	+ mark certain inputs with special Cg binding semantics
		* POSITION, COLOR
	+ uniquely rename param names at domain boundaries
	+ derive the other binding semantics at domain boundaries
		* basically, assign TEXCOORD in sequence
	+ find all quarks required for computation and dump their bodies
		+ uniquely rename function names
	+ split the graph into multiple stages and codegen for each
		+ serialize calc nodes
		+ create the main shader with linking via temporaries

~	memory management for the kdef parser
	+ one ScratchFIFO per module, allocated automatically instead of by the user
	+ replace the token array in xf.nucleus.Code with a Rope
	+ replace regular arrays with ones on the scratch space
	+ replace string.dup with scratch.dupString()
	+ alloc new Foo with scratch._new!(Foo)
	- change the array appending in Enki not to use the GC

~	plug the codegen into the Forward renderer
	+ generate code
	+ create the Cg Effect
	+ instantiate the Effect
	+ bind params
	~ caching
		- one that doesn't suck

+	light kernel instantiation (in the Forward renderer)

+	streamline DSL and kernel/quark/graph semantics

+	surfaces
	+ make like a class and shit
	+ the abilititty to set them for renderables (by index)
	* the surface must have a valid ID before it's passed to the renderer (registered in it)
	* must register surfaces before using them for objects
	
+	kernel graph substitution for single nodes
	* shittt, now this is a tricky one. Touches namespaces for uniforms, code generation,
	  and auto conversions.
	* perhaps it should be made so that each Graph can be codegen'd separately, then subgraphs
	  will simply become functions. Yet then there is the possibilty of doing conversions back and forth
	  and a disparity between what can be done with funcs (semantic exprs possible) and graps (fixed in stone)
	* there's a possibility of turning subgraph Input and Output into Func nodes with signatures resembling:
		void inputPassThrough(in input <from the Input node>, out output <in.input.actual>)
		void outputPassThrough(in input <from the Output node>, out output <in.input.actual>)
	+ done that via special Bridge nodes with similar treatment as Func nodes, but with InOut params

+	default values for params
	* restrict to Data nodes only for now

~	handling of Data nodes
	* after graph fusion, iter all data nodes
		* for each param with a default value, store its name, type and value (e.g. in a ParamList)
		* potentially load textures (one reference per compiled graph)
		* inspect materials and surfaces for overrides, store these as well
	+ fetch the defaults
	+ fetch material data
		+ load textures
	- eliminate all 'default' effect data storage, instead keeping it all in relevant materials,
	  surfaces, lights and assets

-	figure out a way of naming or renaming func params so that kernels may
	be connected without issues
		like input position -> structure output 'position'

~	materials
	+ make like a class and shit
	+ the abilititty to set them for renderables (by index)
	+ textures
	- samplers (via ARB_sampler_objects)
	* the surface must have a valid ID before it's passed to the renderer (registered in it)
	* must register surfaces before using them for objects

~	make OPTLINK not hate me :(((((((((
	+ remove MinTL from the project (xf.input)
	- add per-package / per-module build flags to xfBuild
		- compile xf.omg.core.LinearAlgebra with -O -inline -release, sans -g
		- compile platform modules and GL functions without -g

~	monitor quark files for changes, recompile shaders when needed
	+ track dependencies
		* kernels depending on kernels
		* graphs depending on kernels
		* graphs depending on graphs
		* (?) kernels depending on graphs
		* materials depending on kernels/graphs
		* surfaces depending on kernels/graphs
		* all compiled effects depend on all converters
	+ add opEquals to:
		+ Function
		+ ParamList
		+ Param
		+ SemanticExp
		+ KernelImpl
		+ Value
		+ ParamSemanticExp
		+ ParamDef
		+ Code
		+ ScratchFixedRope
	* might reparse everything, but detect changes and only invalidate the runtime constructs
	  that are affected - recompile Effects, modify material params
	- find all affected items, walk the dependency graph, marking stuff as invalid
	- notify renderers about the invalid elements
		- unregister surfaces and materials
		- invalidate parts of Effect caches
	- delete the olde registry data
		* nothing can retain the defs other than by their name (separately allocated strings)

-	post-processing kernels

-	editor

-	examples
	* deferred rendering
	* recursive rendering

-	thesis

-	party hard
