.d-baseclass = "KDefParserBase";
.d-header = "module xf.nucleus.kdef.KDefParser;
private {{
	import xf.nucleus.Value;
	import xf.nucleus.Code;
	import xf.nucleus.Function;
	import xf.nucleus.kdef.Common;
	import xf.nucleus.kdef.KDefParserBase;
	import xf.nucleus.kernel.KernelDef;
	
	alias char[] string;
}";
.d-classname = "KDefParser";
.d-filename = "KDefParser.d";


// ----------------------------------------------------------------------------------------------------------------


Syntax
	= void parseSyntax(Statement[] statements)
	::= Statement:~statements* eoi;
	
Statement
	= Statement st
	::= AssignStatement:st | ImportStatement:st | ConnectStatement:st | ConverterDeclStatement:st;

// ----------------------------------------------------------------------------------------------------------------
// Statements
	

ConnectStatement
	= new ConnectStatement(string from, string to)
	::= "connect" Identifier:from Identifier:to ";";
	
AssignStatement
	= new AssignStatement(string name, Value value)
	::= Identifier:name "=" Value:value ?!("';' expected") ";";
	
ImportStatement
	= new ImportStatement(string name, string[] what)
	::= "import" String:name [ ":" WildcardIdentifier:~what* % "," ] ";";
	
	WildcardIdentifier
	= string name
	::= (Identifier "*"):name | Identifier:name;
	
ConverterDeclStatement
	= ConverterDeclStatement createConverter(string name, string[] tags, ParamDef[] params, Code code, double cost)
	::= "converter"
	[ "<" KernelTagList:tags ">" ]
	"(" Number:cost ")"
	[Identifier:name] ParamList:params Code:code;
	
// ----------------------------------------------------------------------------------------------------------------
// special Values

QuarkDefValue
	= QuarkDefValue createQuarkDefValue(string superKernel, ParamDef[] params, Code code, string[] tags)
	::= "quark" ["<" KernelTagList:tags ">"] [Identifier:superKernel]
		[ ParamList:params ]
		Code:code;
	
KernelDefValue
	= KernelDefValue createKernelDefValue(string superKernel, ParamDef[] params, string[] tags)
	::= "kernel" ["<" KernelTagList:tags ">"] [Identifier:superKernel]
		ParamList:params;

GraphDefValue
	= GraphDefValue createGraphDefValue(string superKernel, Statement[] stmts, string[] tags)
	::= "graph" ["<" KernelTagList:tags ">"] [Identifier:superKernel]
	"{"
		Statement:~stmts*
	"}";
	
GraphDefNodeValue
	= GraphDefNodeValue createGraphDefNodeValue(VarDef[] vars)
	::= "node"
	"{"
		VarDef:~vars*
	"}";
	
TraitDefValue
	= TraitDefValue createTraitDefValue(string[] values, string defaultValue)
	::= "trait"
	"{"
		Identifier:~values % ","
	"}"
	[ "=" ?!("default value identifier exptected") Identifier:defaultValue ];


// ----------------------------------------------------------------------------------------------------------------

Code
	= new Code(Atom[] tokens)
	::= "{" OpaqueCodeBlock:tokens "}";

KernelTagList
	= string[] tags
	::= Identifier:~tags*;

OpaqueCodeBlock
	= Atom[] tokens
	::= (
		&TOK_LITERAL:~tokens |
		&TOK_STRING:~tokens |
		&TOK_VERBATIM_STRING:~tokens |
		&TOK_NUMBER:~tokens |
		&TOK_IDENT:~tokens |
		"{":~tokens OpaqueCodeBlock:~tokens "}":~tokens
	)*;
	
ParamList
	= ParamDef[] params
	::= "(" Param:~params* % "," ")";
	
Param
	= new ParamDef(
		string dir = "in",
		string type,
		ParamSemanticExp semantic,
		string name,
		Value defaultValue
	)
	::= [ParamDirection:dir]
	Identifier:name
	[ "<" [ParamSemantic:semantic] ">" ]
	[ "=" Value:defaultValue ];

ParamDirection
	= string dir
	::= "in":dir | "out":dir | "inout":dir | "own":dir;
	
ParamType
	= string type
	::= (Identifier ("[" [ParamType | Number] "]")*):type;
	
ParamSemantic
	= ParamSemanticExp value
	::=	ParamSemanticSum:value
	|	ParamSemanticExclusion:value
	|	"(" ParamSemantic:value ")"
	|	ParamSemanticTrait:value;

ParamSemanticSum
	= ParamSemanticExp createParamSemanticSum(ParamSemanticExp a, ParamSemanticExp b)
	::=	(ParamSemanticTrait:a | "(" ParamSemantic:a ")") "+" ParamSemantic:b;

ParamSemanticExclusion
	= ParamSemanticExp createParamSemanticExclusion(ParamSemanticExp a, ParamSemanticExp b)
	::=	(ParamSemanticTrait:a | "(" ParamSemantic:a ")") "-" ParamSemantic:b;

ParamSemanticTrait
	= ParamSemanticExp parseParamSemanticTrait(string name, Value value)
	::= (
			["in" "."] Identifier
		|	"in" "." Identifier "." "actual"
		):name [ Value:value ];

// ----------------------------------------------------------------------------------------------------------------

VarDef
	= VarDef parseVarDef(string name, Value value)
	::= Identifier:name "=" Value:value ";";
	
Value
	= Value value
	::= StringValue:value |
	BooleanValue:value |
	Vector4Value:value |
	Vector3Value:value |
	Vector2Value:value |
	NumberValue:value |
	QuarkDefValue:value |
	KernelDefValue:value |
	GraphDefValue:value |
	GraphDefNodeValue:value |
	TraitDefValue:value |
	ParamListValue:value |
	IdentifierValue:value;
	
BooleanValue
	= new BooleanValue(string value)
	::= ("true" | "false"):value;

IdentifierValue
	= new IdentifierValue(string value)
	::= Identifier:value;

NumberValue
	= new NumberValue(double value)
	::= Number:value;
	
Vector2Value
	= new Vector2Value(double x, double y)
	::= Number:x Number:y;

Vector3Value
	= new Vector3Value(double x, double y, double z)
	::= Number:x Number:y Number:z;

Vector4Value
	= new Vector4Value(double x, double y, double z, double w)
	::= Number:x Number:y Number:z Number:w;

StringValue
	= new StringValue(char[] value)
	::= &TOK_STRING:value;
	
ParamListValue
	= new ParamListValue(ParamDef[] params)
	::= ParamList:params;

Identifier
	= string concatTokens(Atom[] value)
	::= ({&TOK_IDENT} % "."):value;

Number
	= double parseDouble(char[] value)
	::= &TOK_NUMBER:value;

String
	= string value
	::= &TOK_STRING:value;

