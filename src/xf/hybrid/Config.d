// Written in the D programming language

/*
 *  This file has been automatically generated by APaGeD v0.5 beta - Attributed Parser Generator for D.
 *
 *  Sections generated from custom input are marked as "generated code" and
 *  are subject to the terms and conditions stated in one of these sections.
 *  The remaining sections are part of the APaGeD package and subject
 *  to the terms and conditions of the corresponding license.
 *
 *  Attributed Parser Generator for D
 *  Copyright (c) 2007-2008 Jascha Wetzel. All rights reserved
 *  License: Artistic License 2.0
 */

// generated code start

#line 1 "Config.apd"

	module xf.hybrid.Config;
	
	import xf.hybrid.WidgetConfig;
	import tango.io.device.File;
	import tango.core.Exception;
	import tango.util.Convert;
	import tango.io.model.IConduit;
	
	alias char[] string;
	
	
    /+void main(string[] args) {
        if (args.length < 2) {
            throw new Exception("Usage: filename");
		}
		
        SyntaxTree root;
        if (parse("", cast(string)File(args[1]).read(), root, true)) {
        	Config cfg;
        	root.Document(cfg);
        	assert (cfg !is null);
        	Stdout.formatln("Parsed successfully");
        } else {
			Stdout.formatln("Invalid expression: {}", args[1]);
		}
    }+/
    
    Config parseWidgetConfig(InputStream stream, char[] path) {
        SyntaxTree root;
        
        if (stream !is null && parse(path, cast(string)stream.load(), root, true)) {
        	Config cfg;
        	root.Document(cfg);
        	assert (cfg !is null);
        	return cfg;
        } else {
			return null;
		}
    }


    void parseWidgetBody(char[] data, ref PropAssign[] props, ref WidgetSpec[] children) {
        SyntaxTree root;
        if (parse("", "x{" ~ data ~ "}", root, true)) {
        	Config cfg;
        	root.Document(cfg);
        	assert (cfg !is null);
        	props = cfg.widgetSpecs[0].props;
        	children = cfg.widgetSpecs[0].children;
        	//Stdout.formatln("props: {}; children: {}", props.length, children.length);
        } else {
        	throw new Exception("Can't parse: '" ~ data ~ "'");
        }
    }
// generated code end

version(Tango)
{

}
else
{
    import std.string;
    debug import std.stdio;
}

/**************************************************************************************************
    Semantic Analyzer
**************************************************************************************************/

class SemanticException : Exception
{
    this(string msg)
    {
        super(msg);
    }
}

class SyntaxTree
{
    ushort          _ST_rule,
                    _ST_column_number;
    uint            _ST_line_number;

    debug
    {
        string          _ST_node_name,
                        _ST_match,
                        _ST_match_ws;
        SyntaxTree[]    _ST_children;
    }
    else
    {
        union
        {
            struct {
                string      _ST_match,
                            _ST_match_ws;
            }
            struct {
                SyntaxTree[]    _ST_children;
                size_t[2]       _ST_pad;
            }
        }
    }

    bool isTerminal()
    {
        debug   return _ST_match_ws !is null;
        else    return _ST_pad[0] == 0 && _ST_pad[1] == 0;
    }

    debug
    {
        SyntaxTree parent;

        string indent()
        {
            string str;
            for ( SyntaxTree n = parent; n !is null; n = n.parent )
                str ~= "  ";
            return str;
        }

        void print(string indent = "")
        {
            version(Tango)
                Trace.format("{}{}{}", indent, _ST_node_name, _ST_rule);
            else
                writef("%s%s%d", indent, _ST_node_name, _ST_rule);
            if ( _ST_children.length == 0 )
            {
                version(Tango)
                    Trace.formatln(" (\"{}\")", _ST_match);
                else
                    writefln(" (\"%s\")", _ST_match);
            }
            else
            {
                version(Tango)
                    Trace.formatln("");
                else
                    writefln;
            }
            foreach ( c; _ST_children )
                c.print(indent~"  ");
        }
    }

    void opCatAssign(SyntaxTree n)
    {
        _ST_children ~= n;
    }

    // augmented semantic code
// generated code start
    alias _S_Document_default Document;
final void _S_Document_default(ref Config cfg)
{

    switch ( _ST_rule )
    {

    case 2:
        auto WidgetTypeSpecification_node = _ST_children[0];
        auto WidgetTypeSpecification = &WidgetTypeSpecification_node._S_WidgetTypeSpecification_default;
        auto Document_node = _ST_children[1];
        auto Document = &Document_node._S_Document_default;

#line 111 "Config.apd"

		if (cfg is null) {
			cfg = new Config;
		}

		WidgetTypeSpec tmp;
		WidgetTypeSpecification(tmp);
		cfg.widgetTypeSpecs ~= tmp;

		Document(cfg);
        break;

    case 1:
        auto SubWidget_node = _ST_children[0];
        auto SubWidget = &SubWidget_node._S_SubWidget_default;
        auto Document_node = _ST_children[1];
        auto Document = &Document_node._S_Document_default;

#line 98 "Config.apd"

		if (cfg is null) {
			cfg = new Config;
		}
		
		WidgetSpec tmp;
		SubWidget(tmp);
		cfg.widgetSpecs ~= tmp;
		
		Document(cfg);
        break;

    case 0:
        auto StringSpec_node = _ST_children[0];
        auto StringSpec = &StringSpec_node._S_StringSpec_default;
        auto Document_node = _ST_children[1];
        auto Document = &Document_node._S_Document_default;

#line 86 "Config.apd"

		if (cfg is null) {
			cfg = new Config;
		}

		char[] file;
		StringSpec(file);
		cfg.imports ~= file.dup;
		Document(cfg);
        break;
    case 3:
        break;
    default:
        assert(0, "Unexpected rule index "~Int.toString(_ST_rule)~" in Document_default");
    }
}
final void _S_WidgetTypeSpecification_default(out WidgetTypeSpec spec)
{

    switch ( _ST_rule )
    {

    case 4:
        auto Identifier_node = _ST_children[0];
        auto Identifier = &Identifier_node._S_Identifier_default;
        auto WidgetTypeSpecBody_node = _ST_children[1];
        auto WidgetTypeSpecBody = &WidgetTypeSpecBody_node._S_WidgetTypeSpecBody_default;
        auto WidgetTypeExtraSpecification_node = _ST_children[2];
        auto WidgetTypeExtraSpecification = &WidgetTypeExtraSpecification_node._S_WidgetTypeExtraSpecification_default;

#line 129 "Config.apd"

		//Stdout.formatln("parsing a widget type spec");
		spec = new WidgetTypeSpec;
		Identifier(spec.name);
		WidgetTypeSpecBody(spec.items);
        break;
    default:
        assert(0, "Unexpected rule index "~Int.toString(_ST_rule)~" in WidgetTypeSpecification_default");
    }
}
final void _S_WidgetTypeExtraSpecification_default(ref WidgetTypeSpec spec)
{

    switch ( _ST_rule )
    {

    case 5:
        auto PropertyName_node = _ST_children[0];
        auto PropertyName = &PropertyName_node._S_PropertyName_default;
        auto WidgetTypeSpecBody_node = _ST_children[1];
        auto WidgetTypeSpecBody = &WidgetTypeSpecBody_node._S_WidgetTypeSpecBody_default;
        auto WidgetTypeExtraSpecification_node = _ST_children[2];
        auto WidgetTypeExtraSpecification = &WidgetTypeExtraSpecification_node._S_WidgetTypeExtraSpecification_default;

#line 139 "Config.apd"

		assert (false, "TODO?");
		string extraName;
		PropertyName(extraName);
		spec.extraParts[extraName.dup] = (WidgetTypeSpec.Item[]).init;
		WidgetTypeSpecBody(spec.extraParts[extraName]);
		WidgetTypeExtraSpecification(spec);
        break;
    case 6:
        break;
    default:
        assert(0, "Unexpected rule index "~Int.toString(_ST_rule)~" in WidgetTypeExtraSpecification_default");
    }
}
final void _S_WidgetTypeSpecBody_default(ref WidgetTypeSpec.Item[] items)
{

    switch ( _ST_rule )
    {

    case 8:
        auto PropertyAssignment_node = _ST_children[0];
        auto PropertyAssignment = &PropertyAssignment_node._S_PropertyAssignment_default;
        auto WidgetTypeSpecBody_node = _ST_children[1];
        auto WidgetTypeSpecBody = &WidgetTypeSpecBody_node._S_WidgetTypeSpecBody_default;

#line 160 "Config.apd"

		PropAssign tmp;
		PropertyAssignment(tmp);
		items ~= WidgetTypeSpec.Item(tmp);
		WidgetTypeSpecBody(items);
        break;

    case 7:
        auto SubWidget_node = _ST_children[0];
        auto SubWidget = &SubWidget_node._S_SubWidget_default;
        auto WidgetTypeSpecBody_node = _ST_children[1];
        auto WidgetTypeSpecBody = &WidgetTypeSpecBody_node._S_WidgetTypeSpecBody_default;

#line 153 "Config.apd"

		WidgetSpec tmp;
		SubWidget(tmp);
		items ~= WidgetTypeSpec.Item(tmp);
		WidgetTypeSpecBody(items);
        break;
    case 9:
        break;
    default:
        assert(0, "Unexpected rule index "~Int.toString(_ST_rule)~" in WidgetTypeSpecBody_default");
    }
}
final void _S_SubWidget_default(out WidgetSpec spec)
{

    switch ( _ST_rule )
    {

    case 11:
        auto LayoutAttribs_node = _ST_children[0];
        auto LayoutAttribs = &LayoutAttribs_node._S_LayoutAttribs_default;
        auto Name_node = _ST_children[1];
        auto Name = &Name_node._S_NonEmptySubWidgetName_default;
        auto WidgetSpecification_node = _ST_children[2];
        auto WidgetSpecification = &WidgetSpecification_node._S_WidgetSpecification_default;

#line 184 "Config.apd"

		spec = new WidgetSpec;
		
		LayoutAttribs(spec.layoutAttr);
		Name(spec.name);
		spec.createNew = false;
		//Stdout.formatln("2parsing a nested widget: '{}'", spec.name);
		WidgetSpecification(spec);
        break;

    case 10:
        auto LayoutAttribs_node = _ST_children[0];
        auto LayoutAttribs = &LayoutAttribs_node._S_LayoutAttribs_default;
        auto Type_node = _ST_children[1];
        auto Type = &Type_node._S_Identifier_default;
        auto SubWidgetName_node = _ST_children[2];
        auto SubWidgetName = &SubWidgetName_node._S_SubWidgetName_default;
        auto WidgetSpecification_node = _ST_children[3];
        auto WidgetSpecification = &WidgetSpecification_node._S_WidgetSpecification_default;

#line 172 "Config.apd"

		spec = new WidgetSpec;
		
		LayoutAttribs(spec.layoutAttr);
		Type(spec.type);
		SubWidgetName(spec.name);
		spec.createNew = true;
		//Stdout.formatln("1parsing a nested widget: '{}'", spec.name);
		WidgetSpecification(spec);
        break;
    default:
        assert(0, "Unexpected rule index "~Int.toString(_ST_rule)~" in SubWidget_default");
    }
}
final void _S_SubWidgetName_default(out string name)
{

    switch ( _ST_rule )
    {

    case 13:
        auto Identifier_node = _ST_children[0];
        auto Identifier = &Identifier_node._S_Identifier_default;

#line 202 "Config.apd"

		char[] i;
		Identifier(i);
		name = "." ~ i;
        break;

    case 12:
        auto Identifier_node = _ST_children[0];
        auto Identifier = &Identifier_node._S_Identifier_default;

#line 198 "Config.apd"

		Identifier(name);
        break;
    case 14:
        break;
    default:
        assert(0, "Unexpected rule index "~Int.toString(_ST_rule)~" in SubWidgetName_default");
    }
}
final void _S_NonEmptySubWidgetName_default(out string name)
{

    switch ( _ST_rule )
    {

    case 16:
        auto Identifier_node = _ST_children[0];
        auto Identifier = &Identifier_node._S_Identifier_default;

#line 217 "Config.apd"

		char[] i;
		Identifier(i);
		name = "." ~ i;
        break;

    case 15:
        auto Identifier_node = _ST_children[0];
        auto Identifier = &Identifier_node._S_Identifier_default;

#line 213 "Config.apd"

		Identifier(name);
        break;
    default:
        assert(0, "Unexpected rule index "~Int.toString(_ST_rule)~" in NonEmptySubWidgetName_default");
    }
}
final void _S_WidgetSpecification_default(ref WidgetSpec spec)
{

    switch ( _ST_rule )
    {

    case 18:
        auto PropertyName_node = _ST_children[0];
        auto PropertyName = &PropertyName_node._S_PropertyName_default;
        auto WidgetBody_node = _ST_children[1];
        auto WidgetBody = &WidgetBody_node._S_WidgetBody_default;
        auto WidgetExtraSpecification_node = _ST_children[2];
        auto WidgetExtraSpecification = &WidgetExtraSpecification_node._S_WidgetExtraSpecification_default;

#line 231 "Config.apd"

		string extraName;
		PropertyName(extraName);
		spec.extraParts[extraName.dup] = WidgetSpec.ExtraPart.init;
		WidgetBody(spec.extraParts[extraName].props, spec.extraParts[extraName].children);
		WidgetExtraSpecification(spec);
        break;

    case 17:
        auto WidgetBody_node = _ST_children[0];
        auto WidgetBody = &WidgetBody_node._S_WidgetBody_default;
        auto WidgetExtraSpecification_node = _ST_children[1];
        auto WidgetExtraSpecification = &WidgetExtraSpecification_node._S_WidgetExtraSpecification_default;

#line 226 "Config.apd"

		WidgetBody(spec.props, spec.children);
		WidgetExtraSpecification(spec);
        break;
    case 19:
        break;
    default:
        assert(0, "Unexpected rule index "~Int.toString(_ST_rule)~" in WidgetSpecification_default");
    }
}
final void _S_WidgetExtraSpecification_default(ref WidgetSpec spec)
{

    switch ( _ST_rule )
    {

    case 20:
        auto PropertyName_node = _ST_children[0];
        auto PropertyName = &PropertyName_node._S_PropertyName_default;
        auto WidgetBody_node = _ST_children[1];
        auto WidgetBody = &WidgetBody_node._S_WidgetBody_default;
        auto WidgetExtraSpecification_node = _ST_children[2];
        auto WidgetExtraSpecification = &WidgetExtraSpecification_node._S_WidgetExtraSpecification_default;

#line 244 "Config.apd"

		string extraName;
		PropertyName(extraName);
		spec.extraParts[extraName.dup] = WidgetSpec.ExtraPart.init;
		WidgetBody(spec.extraParts[extraName].props, spec.extraParts[extraName].children);
		WidgetExtraSpecification(spec);
        break;
    case 21:
        break;
    default:
        assert(0, "Unexpected rule index "~Int.toString(_ST_rule)~" in WidgetExtraSpecification_default");
    }
}
final void _S_WidgetBody_default(ref PropAssign[] props, ref WidgetSpec[] children)
{

    switch ( _ST_rule )
    {

    case 23:
        auto PropertyAssignment_node = _ST_children[0];
        auto PropertyAssignment = &PropertyAssignment_node._S_PropertyAssignment_default;
        auto WidgetBody_node = _ST_children[1];
        auto WidgetBody = &WidgetBody_node._S_WidgetBody_default;

#line 265 "Config.apd"

		//Stdout.formatln("prop");
		PropAssign pa;
		PropertyAssignment(pa);
		props ~= pa;
		WidgetBody(props, children);
        break;

    case 22:
        auto SubWidget_node = _ST_children[0];
        auto SubWidget = &SubWidget_node._S_SubWidget_default;
        auto WidgetBody_node = _ST_children[1];
        auto WidgetBody = &WidgetBody_node._S_WidgetBody_default;

#line 257 "Config.apd"

		//Stdout.formatln("sub");
		WidgetSpec sub;
		SubWidget(sub);
		children ~= sub;
		WidgetBody(props, children);
        break;
    case 24:
        break;
    default:
        assert(0, "Unexpected rule index "~Int.toString(_ST_rule)~" in WidgetBody_default");
    }
}
final void _S_LayoutAttribs_default(out char[] res)
{

    switch ( _ST_rule )
    {

    case 25:

#line 278 "Config.apd"

		res = _ST_match[1..$-1].dup;
        break;
    case 26:
        break;
    default:
        assert(0, "Unexpected rule index "~Int.toString(_ST_rule)~" in LayoutAttribs_default");
    }
}
final void _S_PropertyAssignment_default(out PropAssign val)
{

    switch ( _ST_rule )
    {

    case 27:
        auto PropertyName_node = _ST_children[0];
        auto PropertyName = &PropertyName_node._S_PropertyName_default;
        auto PropertyValue_node = _ST_children[1];
        auto PropertyValue = &PropertyValue_node._S_PropertyValue_default;

#line 287 "Config.apd"

		PropertyName(val.name);
		PropertyValue(val.value);
        break;
    default:
        assert(0, "Unexpected rule index "~Int.toString(_ST_rule)~" in PropertyAssignment_default");
    }
}
final void _S_PropertyValue_default(out Value val)
{

    switch ( _ST_rule )
    {

    case 31:
        auto ComplexValueSpec_node = _ST_children[0];
        auto ComplexValueSpec = &ComplexValueSpec_node._S_ComplexValueSpec_default;

#line 307 "Config.apd"

		ComplexValue tmp = new ComplexValue;
		ComplexValueSpec(tmp);
		val = Value(tmp);
        break;

    case 30:
        auto Identifier_node = _ST_children[0];
        auto Identifier = &Identifier_node._S_Identifier_default;
        auto PropertyBlock_node = _ST_children[1];
        auto PropertyBlock = &PropertyBlock_node._S_PropertyBlock_default;

#line 304 "Config.apd"

        break;

    case 29:
        auto PropertyBlock_node = _ST_children[0];
        auto PropertyBlock = &PropertyBlock_node._S_PropertyBlock_default;

#line 299 "Config.apd"

		val.type = Value.Type.Block;
		PropertyBlock(val);
        break;

    case 28:
        auto SimpleValue_node = _ST_children[0];
        auto SimpleValue = &SimpleValue_node._S_SimpleValue_default;

#line 295 "Config.apd"

		SimpleValue(val);
        break;
    default:
        assert(0, "Unexpected rule index "~Int.toString(_ST_rule)~" in PropertyValue_default");
    }
}
final void _S_ComplexValueSpec_default(ref ComplexValue val)
{

    switch ( _ST_rule )
    {

    case 33:
        auto SimpleValue_node = _ST_children[0];
        auto SimpleValue = &SimpleValue_node._S_SimpleValue_default;
        auto ComplexValueSpec_node = _ST_children[1];
        auto ComplexValueSpec = &ComplexValueSpec_node._S_ComplexValueSpec_default;

#line 322 "Config.apd"

		Value tmp;
		SimpleValue(tmp);
		val.items ~= tmp;
		ComplexValueSpec(val);
        break;

    case 32:
        auto SimpleValue_node = _ST_children[0];
        auto SimpleValue = &SimpleValue_node._S_SimpleValue_default;

#line 316 "Config.apd"

		Value tmp;
		SimpleValue(tmp);
		val.items ~= tmp;
        break;
    default:
        assert(0, "Unexpected rule index "~Int.toString(_ST_rule)~" in ComplexValueSpec_default");
    }
}
final void _S_FuncArg_default(out Value val)
{

    switch ( _ST_rule )
    {

    case 35:
        auto SimpleValue_node = _ST_children[0];
        auto SimpleValue = &SimpleValue_node._S_SimpleValue_default;
        auto FuncArgList_node = _ST_children[1];
        auto FuncArgList = &FuncArgList_node._S_FuncArgList_default;

#line 344 "Config.apd"

		ComplexValue cmplx = new ComplexValue;
		
		Value tmp;
		SimpleValue(tmp);
		cmplx.items ~= tmp;
		
		ComplexValue tmp2 = new ComplexValue;
		FuncArgList(tmp2.items);
		cmplx.items ~= Value(tmp2);
		
		val = Value(cmplx);
        break;

    case 34:
        auto SimpleValue_node = _ST_children[0];
        auto SimpleValue = &SimpleValue_node._S_SimpleValue_default;

#line 338 "Config.apd"

		Value tmp;
		SimpleValue(tmp);
		val = tmp;
        break;
    default:
        assert(0, "Unexpected rule index "~Int.toString(_ST_rule)~" in FuncArg_default");
    }
}
final void _S_FuncArgList_default(ref Value[] val)
{

    switch ( _ST_rule )
    {

    case 37:
        auto FuncArg_node = _ST_children[0];
        auto FuncArg = &FuncArg_node._S_FuncArg_default;
        auto FuncArgList_node = _ST_children[1];
        auto FuncArgList = &FuncArgList_node._S_FuncArgList_default;

#line 367 "Config.apd"

		Value tmp;
		FuncArg(tmp);
		val ~= tmp;
		FuncArgList(val);
        break;

    case 36:
        auto FuncArg_node = _ST_children[0];
        auto FuncArg = &FuncArg_node._S_FuncArg_default;

#line 361 "Config.apd"

		Value tmp;
		FuncArg(tmp);
		val ~= tmp;
        break;
    default:
        assert(0, "Unexpected rule index "~Int.toString(_ST_rule)~" in FuncArgList_default");
    }
}
final void _S_PropertyBlock_default(ref Value val)
{

    switch ( _ST_rule )
    {

    case 38:
        auto PropertyAssignment_node = _ST_children[0];
        auto PropertyAssignment = &PropertyAssignment_node._S_PropertyAssignment_default;
        auto PropertyBlock_node = _ST_children[1];
        auto PropertyBlock = &PropertyBlock_node._S_PropertyBlock_default;

#line 377 "Config.apd"

		PropAssign tmp;
		PropertyAssignment(tmp);
		val.Block ~= tmp;
		PropertyBlock(val);
        break;
    case 39:
        break;
    default:
        assert(0, "Unexpected rule index "~Int.toString(_ST_rule)~" in PropertyBlock_default");
    }
}
final void _S_SimpleValue_default(out Value val)
{

    switch ( _ST_rule )
    {

    case 46:
        auto StringSpec_node = _ST_children[0];
        auto StringSpec = &StringSpec_node._S_StringSpec_default;

#line 422 "Config.apd"

		string str;
		StringSpec(str);
		val = Value(str);
        break;

    case 45:
        auto Identifier_node = _ST_children[0];
        auto Identifier = &Identifier_node._S_Identifier_default;
        auto FuncArgList_node = _ST_children[1];
        auto FuncArgList = &FuncArgList_node._S_FuncArgList_default;

#line 415 "Config.apd"

		FuncCallValue tmp;
		Identifier(tmp.name);
		FuncArgList(tmp.args);
		val = Value(tmp);
        break;

    case 44:
        auto FloatingPointNumber_node = _ST_children[0];
        auto FloatingPointNumber = &FloatingPointNumber_node._S_FloatingPointNumber_default;

#line 409 "Config.apd"

		float f;
		FloatingPointNumber(f);
		val = Value(f);
        break;

    case 43:
        auto Number_node = _ST_children[0];
        auto Number = &Number_node._S_Number_default;

#line 403 "Config.apd"

		int i;
		Number(i);
		val = Value(i);
        break;

    case 42:
        auto PropertyName_node = _ST_children[0];
        auto PropertyName = &PropertyName_node._S_PropertyName_default;

#line 397 "Config.apd"

		string str;
		PropertyName(str);
		val = Value(str);
        break;

    case 41:

#line 393 "Config.apd"

		val = Value(false);
        break;

    case 40:

#line 389 "Config.apd"

		val = Value(true);
        break;
    default:
        assert(0, "Unexpected rule index "~Int.toString(_ST_rule)~" in SimpleValue_default");
    }
}
final void _S_PropertyName_default(out string str)
{

    switch ( _ST_rule )
    {

    case 48:
        auto Identifier_node = _ST_children[0];
        auto Identifier = &Identifier_node._S_Identifier_default;

#line 439 "Config.apd"

		Identifier(str);
        break;

    case 47:
        auto Identifier_node = _ST_children[0];
        auto Identifier = &Identifier_node._S_Identifier_default;
        auto PropertyName_node = _ST_children[1];
        auto PropertyName = &PropertyName_node._S_PropertyName_default;

#line 431 "Config.apd"

		Identifier(str);
		str ~= ".";
		string tmp;
		PropertyName(tmp);
		str ~= tmp;
        break;
    default:
        assert(0, "Unexpected rule index "~Int.toString(_ST_rule)~" in PropertyName_default");
    }
}
final void _S_Identifier_default(out string str)
{

    switch ( _ST_rule )
    {

    case 49:

#line 446 "Config.apd"

		str = _ST_match;
        break;
    default:
        assert(0, "Unexpected rule index "~Int.toString(_ST_rule)~" in Identifier_default");
    }
}
final void _S_Number_default(out int val)
{

    switch ( _ST_rule )
    {

    case 50:

#line 453 "Config.apd"

		val = to!(int)(_ST_match);
        break;
    default:
        assert(0, "Unexpected rule index "~Int.toString(_ST_rule)~" in Number_default");
    }
}
final void _S_FloatingPointNumber_default(out float val)
{

    switch ( _ST_rule )
    {

    case 51:

#line 460 "Config.apd"

		val = to!(float)(_ST_match);
        break;
    default:
        assert(0, "Unexpected rule index "~Int.toString(_ST_rule)~" in FloatingPointNumber_default");
    }
}
final void _S_StringSpec_default(out string val)
{

    switch ( _ST_rule )
    {

    case 52:

#line 467 "Config.apd"

		val = _ST_match[1..$-1];
        break;
    default:
        assert(0, "Unexpected rule index "~Int.toString(_ST_rule)~" in StringSpec_default");
    }
}

}


// generated code end

#line 964 "Config.d"
// Written in the D programming language

/*
 *  This file has been automatically generated by APaGeD v0.5 beta - Attributed Parser Generator for D.
 *
 *  Sections generated from custom input are marked as "generated code" and
 *  are subject to the terms and conditions stated in one of these sections.
 *  The remaining sections are part of the APaGeD package and subject
 *  to the terms and conditions of the corresponding license.
 *
 *  Attributed Parser Generator for D
 *  Copyright (c) 2007-2008 Jascha Wetzel. All rights reserved
 *  License: Artistic License 2.0
 */

/**************************************************************************************************
    Lexer
**************************************************************************************************/

version(Tango)
// the following block is stolen from phobos.
// the copyright notice applies for this block only.
{
/*
 *  Copyright (C) 2003-2004 by Digital Mars, www.digitalmars.com
 *  Written by Walter Bright
 *
 *  This software is provided 'as-is', without any express or implied
 *  warranty. In no event will the authors be held liable for any damages
 *  arising from the use of this software.
 *
 *  Permission is granted to anyone to use this software for any purpose,
 *  including commercial applications, and to alter it and redistribute it
 *  freely, subject to the following restrictions:
 *
 *  o  The origin of this software must not be misrepresented; you must not
 *     claim that you wrote the original software. If you use this software
 *     in a product, an acknowledgment in the product documentation would be
 *     appreciated but is not required.
 *  o  Altered source versions must be plainly marked as such, and must not
 *     be misrepresented as being the original software.
 *  o  This notice may not be removed or altered from any source
 *     distribution.
 */

bool isValidDchar(dchar c)
{
    /* Note: FFFE and FFFF are specifically permitted by the
     * Unicode standard for application internal use, but are not
     * allowed for interchange.
     * (thanks to Arcane Jill)
     */

    return c < 0xD800 ||
	(c > 0xDFFF && c <= 0x10FFFF /*&& c != 0xFFFE && c != 0xFFFF*/);
}

/***************
 * Decodes and returns character starting at s[idx]. idx is advanced past the
 * decoded character. If the character is not well formed, a UtfException is
 * thrown and idx remains unchanged.
 */

dchar decode(in char[] s, inout size_t idx)
    {
	size_t len = s.length;
	dchar V;
	size_t i = idx;
	char u = s[i];

	if (u & 0x80)
	{   uint n;
	    char u2;

	    /* The following encodings are valid, except for the 5 and 6 byte
	     * combinations:
	     *	0xxxxxxx
	     *	110xxxxx 10xxxxxx
	     *	1110xxxx 10xxxxxx 10xxxxxx
	     *	11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
	     *	111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
	     *	1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
	     */
	    for (n = 1; ; n++)
	    {
		if (n > 4)
		    goto Lerr;		// only do the first 4 of 6 encodings
		if (((u << n) & 0x80) == 0)
		{
		    if (n == 1)
			goto Lerr;
		    break;
		}
	    }

	    // Pick off (7 - n) significant bits of B from first byte of octet
	    V = cast(dchar)(u & ((1 << (7 - n)) - 1));

	    if (i + (n - 1) >= len)
		goto Lerr;			// off end of string

	    /* The following combinations are overlong, and illegal:
	     *	1100000x (10xxxxxx)
	     *	11100000 100xxxxx (10xxxxxx)
	     *	11110000 1000xxxx (10xxxxxx 10xxxxxx)
	     *	11111000 10000xxx (10xxxxxx 10xxxxxx 10xxxxxx)
	     *	11111100 100000xx (10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx)
	     */
	    u2 = s[i + 1];
	    if ((u & 0xFE) == 0xC0 ||
		(u == 0xE0 && (u2 & 0xE0) == 0x80) ||
		(u == 0xF0 && (u2 & 0xF0) == 0x80) ||
		(u == 0xF8 && (u2 & 0xF8) == 0x80) ||
		(u == 0xFC && (u2 & 0xFC) == 0x80))
		goto Lerr;			// overlong combination

	    for (uint j = 1; j != n; j++)
	    {
		u = s[i + j];
		if ((u & 0xC0) != 0x80)
		    goto Lerr;			// trailing bytes are 10xxxxxx
		V = (V << 6) | (u & 0x3F);
	    }
	    if (!isValidDchar(V))
		goto Lerr;
	    i += n;
	}
	else
	{
	    V = cast(dchar) u;
	    i++;
	}

	idx = i;
	return V;

      Lerr:
	throw new Exception("4invalid UTF-8 sequence");
    }
}
else
{
    import std.utf;
}

// lexer code
// generated code start
// ((?import)|(?widget)|(?\{)|(?\})|(?@)|(?new)|(?\.)|(?;)|(?\[[^\]]+\])|(?=)|(?graphic)|(?\()|(?\))|(?,)|(?true)|(?false)|(?[a-zA-Z_][0-9a-zA-Z_]*)|(?-?[0-9][0-9_]*)|(?(-?[0-9][0-9_]*\.[0-9][0-9_]*)|(-?\.[0-9][0-9_]*))|(?"([^"]|(\\"))*")).*?
bool mainLexer(char[] input, out uint token, out char[] match)
{
    uint s = 0;
    static int r40=-1, r41=-1, r42=-1, r43=-1, r44=-1, r45=-1, r46=-1, r47=-1, r48=-1, r49=-1, 
        r50=-1, r51=-1, r52=-1, r53=-1, r54=-1, r55=-1, r56=-1, r57=-1, r58=-1, r59=-1, 
        r60=-1, r61=-1, r62=-1, r63=-1, r64=-1, r65=-1, r66=-1, r67=-1, r68=-1, r69=-1, 
        r70=-1;

    for ( size_t p, next_p; p < input.length; )
    {
        dchar c = cast(dchar)input[p];
        if ( c & 0x80 )
            decode(input, next_p);
        else
            next_p = p+1;
        switch ( s )
        {
            case 0:
                if ( c == 0x7d ) {
                    s = 20;
                    p = next_p;
                    r50 = p;
                }
                else if ( c == 0x28 ) {
                    s = 2;
                    p = next_p;
                    r40 = p;
                }
                else if ( c == 0x5b ) {
                    s = 12;
                    p = next_p;
                }
                else if ( c == 0x2c ) {
                    s = 4;
                    p = next_p;
                    r42 = p;
                }
                else if ( c == 0x66 ) {
                    s = 13;
                    p = next_p;
                    r48 = p;
                }
                else if ( c == 0x2e ) {
                    s = 6;
                    p = next_p;
                    r43 = p;
                }
                else if ( c == 0x67 ) {
                    s = 14;
                    p = next_p;
                    r48 = p;
                }
                else if ( c == 0x3b ) {
                    s = 8;
                    p = next_p;
                    r45 = p;
                }
                else if ( c == 0x69 ) {
                    s = 15;
                    p = next_p;
                    r48 = p;
                }
                else if ( c == 0x40 ) {
                    s = 10;
                    p = next_p;
                    r47 = p;
                }
                else if ( c == 0x6e ) {
                    s = 16;
                    p = next_p;
                    r48 = p;
                }
                else if ( c == 0x29 ) {
                    s = 3;
                    p = next_p;
                    r41 = p;
                }
                else if ( c == 0x74 ) {
                    s = 17;
                    p = next_p;
                    r48 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 ) {
                    s = 7;
                    p = next_p;
                    r44 = p;
                }
                else if ( c == 0x77 ) {
                    s = 18;
                    p = next_p;
                    r48 = p;
                }
                else if ( c == 0x7b ) {
                    s = 19;
                    p = next_p;
                    r49 = p;
                }
                else if ( c == 0x2d ) {
                    s = 5;
                    p = next_p;
                }
                else if ( c == 0x22 ) {
                    s = 1;
                    p = next_p;
                }
                else if ( c == 0x3d ) {
                    s = 9;
                    p = next_p;
                    r46 = p;
                }
                else if ( c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x65 || c == 0x68 || c >= 0x6a && c <= 0x6d || c >= 0x6f && c <= 0x73 || c >= 0x75 && c <= 0x76 || c >= 0x78 && c <= 0x7a ) {
                    s = 11;
                    p = next_p;
                    r48 = p;
                }
                else
                    return false;
                break;
            case 1:
                if ( c == 0x5c ) {
                    s = 84;
                    p = next_p;
                }
                else if ( c == 0x22 ) {
                    s = 83;
                    p = next_p;
                    r51 = p;
                }
                else if ( c >= 0x0 && c <= 0x10ffff ) {
                    s = 1;
                    p = next_p;
                }
                else
                    return false;
                break;
            case 2:
                goto finish2;
            case 3:
                goto finish3;
            case 4:
                goto finish4;
            case 5:
                if ( c >= 0x30 && c <= 0x39 ) {
                    s = 7;
                    p = next_p;
                    r44 = p;
                }
                else if ( c == 0x2e ) {
                    s = 77;
                    p = next_p;
                }
                else
                    return false;
                break;
            case 6:
                if ( c >= 0x30 && c <= 0x39 ) {
                    s = 71;
                    p = next_p;
                    r52 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 74;
                    p = next_p;
                }
                else
                    goto finish6;
                break;
            case 7:
                if ( c == 0x2e ) {
                    s = 69;
                    p = next_p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c == 0x5f ) {
                    s = 70;
                    p = next_p;
                    r53 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 68;
                    p = next_p;
                }
                else
                    goto finish7;
                break;
            case 8:
                goto finish8;
            case 9:
                goto finish9;
            case 10:
                goto finish10;
            case 11:
                if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 24;
                    p = next_p;
                    r54 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 23;
                    p = next_p;
                }
                else
                    goto finish11;
                break;
            case 12:
                if ( c >= 0x0 && c <= 0x5c || c >= 0x5e && c <= 0x10ffff ) {
                    s = 62;
                    p = next_p;
                }
                else
                    return false;
                break;
            case 13:
                if ( c == 0x61 ) {
                    s = 56;
                    p = next_p;
                    r54 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 24;
                    p = next_p;
                    r54 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 23;
                    p = next_p;
                }
                else
                    goto finish13;
                break;
            case 14:
                if ( c == 0x72 ) {
                    s = 48;
                    p = next_p;
                    r54 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 24;
                    p = next_p;
                    r54 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 23;
                    p = next_p;
                }
                else
                    goto finish14;
                break;
            case 15:
                if ( c == 0x6d ) {
                    s = 41;
                    p = next_p;
                    r54 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 24;
                    p = next_p;
                    r54 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 23;
                    p = next_p;
                }
                else
                    goto finish15;
                break;
            case 16:
                if ( c == 0x65 ) {
                    s = 37;
                    p = next_p;
                    r54 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 24;
                    p = next_p;
                    r54 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 23;
                    p = next_p;
                }
                else
                    goto finish16;
                break;
            case 17:
                if ( c == 0x72 ) {
                    s = 32;
                    p = next_p;
                    r54 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 24;
                    p = next_p;
                    r54 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 23;
                    p = next_p;
                }
                else
                    goto finish17;
                break;
            case 18:
                if ( c == 0x69 ) {
                    s = 25;
                    p = next_p;
                    r54 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 24;
                    p = next_p;
                    r54 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 23;
                    p = next_p;
                }
                else
                    goto finish18;
                break;
            case 19:
                goto finish19;
            case 20:
                goto finish20;
            case 21:
                if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 20;
                    p = next_p;
                }
                else
                    goto finish21;
                break;
            case 22:
                if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 19;
                    p = next_p;
                }
                else
                    goto finish22;
                break;
            case 23:
                goto finish23;
            case 24:
                if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 24;
                    p = next_p;
                    r48 = r54;
                    r54 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 23;
                    p = next_p;
                    r48 = r54;
                }
                else
                    goto finish24;
                break;
            case 25:
                if ( c == 0x64 ) {
                    s = 26;
                    p = next_p;
                    r55 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 24;
                    p = next_p;
                    r48 = r54;
                    r54 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 23;
                    p = next_p;
                    r48 = r54;
                }
                else
                    goto finish25;
                break;
            case 26:
                if ( c == 0x67 ) {
                    s = 27;
                    p = next_p;
                    r56 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 24;
                    p = next_p;
                    r48 = r55;
                    r54 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 23;
                    p = next_p;
                    r48 = r55;
                }
                else
                    goto finish26;
                break;
            case 27:
                if ( c == 0x65 ) {
                    s = 28;
                    p = next_p;
                    r57 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 24;
                    p = next_p;
                    r48 = r56;
                    r54 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 23;
                    p = next_p;
                    r48 = r56;
                }
                else
                    goto finish27;
                break;
            case 28:
                if ( c == 0x74 ) {
                    s = 29;
                    p = next_p;
                    r58 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 24;
                    p = next_p;
                    r48 = r57;
                    r54 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 23;
                    p = next_p;
                    r48 = r57;
                }
                else
                    goto finish28;
                break;
            case 29:
                if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 31;
                    p = next_p;
                    r59 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 30;
                    p = next_p;
                }
                else
                    goto finish29;
                break;
            case 30:
                goto finish30;
            case 31:
                if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 24;
                    p = next_p;
                    r48 = r59;
                    r54 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 23;
                    p = next_p;
                    r48 = r59;
                }
                else
                    goto finish31;
                break;
            case 32:
                if ( c == 0x75 ) {
                    s = 33;
                    p = next_p;
                    r55 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 24;
                    p = next_p;
                    r48 = r54;
                    r54 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 23;
                    p = next_p;
                    r48 = r54;
                }
                else
                    goto finish32;
                break;
            case 33:
                if ( c == 0x65 ) {
                    s = 34;
                    p = next_p;
                    r60 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 24;
                    p = next_p;
                    r48 = r55;
                    r54 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 23;
                    p = next_p;
                    r48 = r55;
                }
                else
                    goto finish33;
                break;
            case 34:
                if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 36;
                    p = next_p;
                    r57 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 35;
                    p = next_p;
                }
                else
                    goto finish34;
                break;
            case 35:
                goto finish35;
            case 36:
                if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 24;
                    p = next_p;
                    r48 = r57;
                    r54 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 23;
                    p = next_p;
                    r48 = r57;
                }
                else
                    goto finish36;
                break;
            case 37:
                if ( c == 0x77 ) {
                    s = 38;
                    p = next_p;
                    r61 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 24;
                    p = next_p;
                    r48 = r54;
                    r54 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 23;
                    p = next_p;
                    r48 = r54;
                }
                else
                    goto finish37;
                break;
            case 38:
                if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 40;
                    p = next_p;
                    r56 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 39;
                    p = next_p;
                }
                else
                    goto finish38;
                break;
            case 39:
                goto finish39;
            case 40:
                if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 24;
                    p = next_p;
                    r48 = r56;
                    r54 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 23;
                    p = next_p;
                    r48 = r56;
                }
                else
                    goto finish40;
                break;
            case 41:
                if ( c == 0x70 ) {
                    s = 42;
                    p = next_p;
                    r55 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 24;
                    p = next_p;
                    r48 = r54;
                    r54 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 23;
                    p = next_p;
                    r48 = r54;
                }
                else
                    goto finish41;
                break;
            case 42:
                if ( c == 0x6f ) {
                    s = 43;
                    p = next_p;
                    r56 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 24;
                    p = next_p;
                    r48 = r55;
                    r54 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 23;
                    p = next_p;
                    r48 = r55;
                }
                else
                    goto finish42;
                break;
            case 43:
                if ( c == 0x72 ) {
                    s = 44;
                    p = next_p;
                    r57 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 24;
                    p = next_p;
                    r48 = r56;
                    r54 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 23;
                    p = next_p;
                    r48 = r56;
                }
                else
                    goto finish43;
                break;
            case 44:
                if ( c == 0x74 ) {
                    s = 45;
                    p = next_p;
                    r62 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 24;
                    p = next_p;
                    r48 = r57;
                    r54 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 23;
                    p = next_p;
                    r48 = r57;
                }
                else
                    goto finish44;
                break;
            case 45:
                if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 31;
                    p = next_p;
                    r59 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 46;
                    p = next_p;
                }
                else
                    goto finish45;
                break;
            case 46:
                goto finish46;
            case 47:
                if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 24;
                    p = next_p;
                    r48 = r59;
                    r54 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 23;
                    p = next_p;
                    r48 = r59;
                }
                else
                    goto finish47;
                break;
            case 48:
                if ( c == 0x61 ) {
                    s = 49;
                    p = next_p;
                    r55 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 24;
                    p = next_p;
                    r48 = r54;
                    r54 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 23;
                    p = next_p;
                    r48 = r54;
                }
                else
                    goto finish48;
                break;
            case 49:
                if ( c == 0x70 ) {
                    s = 50;
                    p = next_p;
                    r56 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 24;
                    p = next_p;
                    r48 = r55;
                    r54 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 23;
                    p = next_p;
                    r48 = r55;
                }
                else
                    goto finish49;
                break;
            case 50:
                if ( c == 0x68 ) {
                    s = 51;
                    p = next_p;
                    r57 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 24;
                    p = next_p;
                    r48 = r56;
                    r54 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 23;
                    p = next_p;
                    r48 = r56;
                }
                else
                    goto finish50;
                break;
            case 51:
                if ( c == 0x69 ) {
                    s = 52;
                    p = next_p;
                    r63 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 24;
                    p = next_p;
                    r48 = r57;
                    r54 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 23;
                    p = next_p;
                    r48 = r57;
                }
                else
                    goto finish51;
                break;
            case 52:
                if ( c == 0x63 ) {
                    s = 53;
                    p = next_p;
                    r64 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 24;
                    p = next_p;
                    r48 = r63;
                    r54 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 23;
                    p = next_p;
                    r48 = r63;
                }
                else
                    goto finish52;
                break;
            case 53:
                if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 55;
                    p = next_p;
                    r65 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 54;
                    p = next_p;
                }
                else
                    goto finish53;
                break;
            case 54:
                goto finish54;
            case 55:
                if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 24;
                    p = next_p;
                    r48 = r65;
                    r54 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 23;
                    p = next_p;
                    r48 = r65;
                }
                else
                    goto finish55;
                break;
            case 56:
                if ( c == 0x6c ) {
                    s = 57;
                    p = next_p;
                    r55 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 24;
                    p = next_p;
                    r48 = r54;
                    r54 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 23;
                    p = next_p;
                    r48 = r54;
                }
                else
                    goto finish56;
                break;
            case 57:
                if ( c == 0x73 ) {
                    s = 58;
                    p = next_p;
                    r56 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 24;
                    p = next_p;
                    r48 = r55;
                    r54 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 23;
                    p = next_p;
                    r48 = r55;
                }
                else
                    goto finish57;
                break;
            case 58:
                if ( c == 0x65 ) {
                    s = 59;
                    p = next_p;
                    r66 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 24;
                    p = next_p;
                    r48 = r56;
                    r54 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 23;
                    p = next_p;
                    r48 = r56;
                }
                else
                    goto finish58;
                break;
            case 59:
                if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 61;
                    p = next_p;
                    r63 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 60;
                    p = next_p;
                }
                else
                    goto finish59;
                break;
            case 60:
                goto finish60;
            case 61:
                if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 24;
                    p = next_p;
                    r48 = r63;
                    r54 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 23;
                    p = next_p;
                    r48 = r63;
                }
                else
                    goto finish61;
                break;
            case 62:
                if ( c == 0x5d ) {
                    s = 63;
                    p = next_p;
                    r67 = p;
                }
                else if ( c >= 0x0 && c <= 0x10ffff ) {
                    s = 62;
                    p = next_p;
                }
                else
                    return false;
                break;
            case 63:
                goto finish63;
            case 64:
                if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 63;
                    p = next_p;
                }
                else
                    goto finish64;
                break;
            case 65:
                if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 10;
                    p = next_p;
                }
                else
                    goto finish65;
                break;
            case 66:
                if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 9;
                    p = next_p;
                }
                else
                    goto finish66;
                break;
            case 67:
                if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 8;
                    p = next_p;
                }
                else
                    goto finish67;
                break;
            case 68:
                goto finish68;
            case 69:
                if ( c >= 0x30 && c <= 0x39 ) {
                    s = 71;
                    p = next_p;
                    r52 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 68;
                    p = next_p;
                }
                else
                    goto finish69;
                break;
            case 70:
                if ( c == 0x2e ) {
                    s = 69;
                    p = next_p;
                    r44 = r53;
                }
                else if ( c >= 0x30 && c <= 0x39 || c == 0x5f ) {
                    s = 70;
                    p = next_p;
                    r44 = r53;
                    r53 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 68;
                    p = next_p;
                    r44 = r53;
                }
                else
                    goto finish70;
                break;
            case 71:
                if ( c >= 0x30 && c <= 0x39 || c == 0x5f ) {
                    s = 73;
                    p = next_p;
                    r68 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 72;
                    p = next_p;
                }
                else
                    goto finish71;
                break;
            case 72:
                goto finish72;
            case 73:
                if ( c >= 0x30 && c <= 0x39 || c == 0x5f ) {
                    s = 73;
                    p = next_p;
                    r52 = r68;
                    r68 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 72;
                    p = next_p;
                    r52 = r68;
                }
                else
                    goto finish73;
                break;
            case 74:
                goto finish74;
            case 75:
                if ( c >= 0x30 && c <= 0x39 || c == 0x5f ) {
                    s = 73;
                    p = next_p;
                    r68 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 72;
                    p = next_p;
                }
                else
                    goto finish75;
                break;
            case 76:
                if ( c >= 0x30 && c <= 0x39 || c == 0x5f ) {
                    s = 73;
                    p = next_p;
                    r52 = r68;
                    r68 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 72;
                    p = next_p;
                    r52 = r68;
                }
                else
                    goto finish76;
                break;
            case 77:
                if ( c >= 0x30 && c <= 0x39 ) {
                    s = 78;
                    p = next_p;
                    r69 = p;
                }
                else
                    return false;
                break;
            case 78:
                if ( c >= 0x30 && c <= 0x39 || c == 0x5f ) {
                    s = 73;
                    p = next_p;
                    r52 = r69;
                    r68 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 72;
                    p = next_p;
                    r52 = r69;
                }
                else
                    goto finish78;
                break;
            case 79:
                if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 4;
                    p = next_p;
                }
                else
                    goto finish79;
                break;
            case 80:
                if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 3;
                    p = next_p;
                }
                else
                    goto finish80;
                break;
            case 81:
                if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 2;
                    p = next_p;
                }
                else
                    goto finish81;
                break;
            case 82:
                if ( c == 0x5c ) {
                    s = 84;
                    p = next_p;
                }
                else if ( c == 0x22 ) {
                    s = 83;
                    p = next_p;
                    r51 = p;
                }
                else if ( c >= 0x0 && c <= 0x10ffff ) {
                    s = 1;
                    p = next_p;
                }
                else
                    return false;
                break;
            case 83:
                if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 87;
                    p = next_p;
                    r70 = r51;
                }
                else
                    goto finish83;
                break;
            case 84:
                if ( c == 0x5c ) {
                    s = 84;
                    p = next_p;
                }
                else if ( c == 0x22 ) {
                    s = 85;
                    p = next_p;
                    r51 = p;
                }
                else if ( c >= 0x0 && c <= 0x10ffff ) {
                    s = 1;
                    p = next_p;
                }
                else
                    return false;
                break;
            case 85:
                if ( c == 0x5c ) {
                    s = 88;
                    p = next_p;
                }
                else if ( c == 0x22 ) {
                    s = 87;
                    p = next_p;
                    r70 = p;
                }
                else if ( c >= 0x0 && c <= 0x8 || c >= 0x14 && c <= 0x1f || c >= 0x7f && c <= 0x9f || c >= 0x250 && c <= 0x20a2 || c >= 0x20b6 && c <= 0x10ffff ) {
                    s = 1;
                    p = next_p;
                }
                else if ( c >= 0x0 && c <= 0x10ffff ) {
                    s = 85;
                    p = next_p;
                }
                else
                    goto finish85;
                break;
            case 86:
                if ( c == 0x5c ) {
                    s = 88;
                    p = next_p;
                }
                else if ( c == 0x22 ) {
                    s = 87;
                    p = next_p;
                    r70 = p;
                }
                else if ( c >= 0x0 && c <= 0x8 || c >= 0x14 && c <= 0x1f || c >= 0x7f && c <= 0x9f || c >= 0x250 && c <= 0x20a2 || c >= 0x20b6 && c <= 0x10ffff ) {
                    s = 1;
                    p = next_p;
                }
                else if ( c >= 0x0 && c <= 0x10ffff ) {
                    s = 85;
                    p = next_p;
                }
                else
                    goto finish86;
                break;
            case 87:
                goto finish87;
            case 88:
                if ( c == 0x5c ) {
                    s = 88;
                    p = next_p;
                }
                else if ( c == 0x22 ) {
                    s = 89;
                    p = next_p;
                    r70 = p;
                }
                else if ( c >= 0x0 && c <= 0x8 || c >= 0x14 && c <= 0x1f || c >= 0x7f && c <= 0x9f || c >= 0x250 && c <= 0x20a2 || c >= 0x20b6 && c <= 0x10ffff ) {
                    s = 1;
                    p = next_p;
                }
                else if ( c >= 0x0 && c <= 0x10ffff ) {
                    s = 85;
                    p = next_p;
                }
                else
                    goto finish88;
                break;
            case 89:
                if ( c == 0x5c ) {
                    s = 88;
                    p = next_p;
                    r51 = r70;
                }
                else if ( c == 0x22 ) {
                    s = 87;
                    p = next_p;
                    r51 = r70;
                    r70 = p;
                }
                else if ( c >= 0x0 && c <= 0x8 || c >= 0x14 && c <= 0x1f || c >= 0x7f && c <= 0x9f || c >= 0x250 && c <= 0x20a2 || c >= 0x20b6 && c <= 0x10ffff ) {
                    s = 1;
                    p = next_p;
                }
                else if ( c >= 0x0 && c <= 0x10ffff ) {
                    s = 85;
                    p = next_p;
                    r51 = r70;
                }
                else
                    goto finish89;
                break;
            case 90:
                if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 87;
                    p = next_p;
                }
                else
                    goto finish90;
                break;
            default:
                assert(0);
        }
    }

    switch ( s )
    {
        case 2: finish2:
        case 81: finish81:
            match = input[0 .. r40];
            token = 11;
            break;
        case 3: finish3:
        case 80: finish80:
            match = input[0 .. r41];
            token = 12;
            break;
        case 4: finish4:
        case 79: finish79:
            match = input[0 .. r42];
            token = 13;
            break;
        case 6: finish6:
        case 74: finish74:
            match = input[0 .. r43];
            token = 6;
            break;
        case 7: finish7:
        case 68: finish68:
        case 69: finish69:
            match = input[0 .. r44];
            token = 17;
            break;
        case 8: finish8:
        case 67: finish67:
            match = input[0 .. r45];
            token = 7;
            break;
        case 9: finish9:
        case 66: finish66:
            match = input[0 .. r46];
            token = 9;
            break;
        case 10: finish10:
        case 65: finish65:
            match = input[0 .. r47];
            token = 4;
            break;
        case 11: finish11:
        case 13: finish13:
        case 14: finish14:
        case 15: finish15:
        case 16: finish16:
        case 17: finish17:
        case 18: finish18:
        case 23: finish23:
            match = input[0 .. r48];
            token = 16;
            break;
        case 19: finish19:
        case 22: finish22:
            match = input[0 .. r49];
            token = 2;
            break;
        case 20: finish20:
        case 21: finish21:
            match = input[0 .. r50];
            token = 3;
            break;
        case 24: finish24:
        case 25: finish25:
        case 32: finish32:
        case 37: finish37:
        case 41: finish41:
        case 48: finish48:
        case 56: finish56:
            match = input[0 .. r54];
            token = 16;
            break;
        case 26: finish26:
        case 33: finish33:
        case 42: finish42:
        case 49: finish49:
        case 57: finish57:
            match = input[0 .. r55];
            token = 16;
            break;
        case 27: finish27:
        case 40: finish40:
        case 43: finish43:
        case 50: finish50:
        case 58: finish58:
            match = input[0 .. r56];
            token = 16;
            break;
        case 28: finish28:
        case 36: finish36:
        case 44: finish44:
        case 51: finish51:
            match = input[0 .. r57];
            token = 16;
            break;
        case 29: finish29:
        case 30: finish30:
            match = input[0 .. r58];
            token = 1;
            break;
        case 31: finish31:
        case 47: finish47:
            match = input[0 .. r59];
            token = 16;
            break;
        case 34: finish34:
        case 35: finish35:
            match = input[0 .. r60];
            token = 14;
            break;
        case 38: finish38:
        case 39: finish39:
            match = input[0 .. r61];
            token = 5;
            break;
        case 45: finish45:
        case 46: finish46:
            match = input[0 .. r62];
            token = 0;
            break;
        case 52: finish52:
        case 61: finish61:
            match = input[0 .. r63];
            token = 16;
            break;
        case 53: finish53:
        case 54: finish54:
            match = input[0 .. r64];
            token = 10;
            break;
        case 55: finish55:
            match = input[0 .. r65];
            token = 16;
            break;
        case 59: finish59:
        case 60: finish60:
            match = input[0 .. r66];
            token = 15;
            break;
        case 63: finish63:
        case 64: finish64:
            match = input[0 .. r67];
            token = 8;
            break;
        case 70: finish70:
            match = input[0 .. r53];
            token = 17;
            break;
        case 71: finish71:
        case 72: finish72:
        case 75: finish75:
            match = input[0 .. r52];
            token = 18;
            break;
        case 73: finish73:
        case 76: finish76:
            match = input[0 .. r68];
            token = 18;
            break;
        case 78: finish78:
            match = input[0 .. r69];
            token = 18;
            break;
        case 83: finish83:
        case 85: finish85:
        case 86: finish86:
        case 88: finish88:
            match = input[0 .. r51];
            token = 19;
            break;
        case 87: finish87:
        case 89: finish89:
        case 90: finish90:
            match = input[0 .. r70];
            token = 19;
            break;
        default:
            return false;
    }

    return true;
}
// ((?[\n\r\t ]+)|(?//[^\n]*)|(?/\*([^\*]|\*>/)*\*/)|(?/\+)|(?\+/)|(?[^#/\+\*\n\r\t ]+)|(?\+)|(?\*)|(?/)).*?
bool wsLexer(char[] input, out uint token, out char[] match)
{
    uint s = 0;
    static int r18=-1, r19=-1, r20=-1, r21=-1, r22=-1, r23=-1, r24=-1, r25=-1, r26=-1, r27=-1, 
        r28=-1, r29=-1, r30=-1, r31=-1;

    for ( size_t p, next_p; p < input.length; )
    {
        dchar c = cast(dchar)input[p];
        if ( c & 0x80 )
            decode(input, next_p);
        else
            next_p = p+1;
        switch ( s )
        {
            case 0:
                if ( c == 0x2f ) {
                    s = 5;
                    p = next_p;
                    r21 = p;
                }
                else if ( c == 0x2b ) {
                    s = 4;
                    p = next_p;
                    r20 = p;
                }
                else if ( c == 0x2a ) {
                    s = 3;
                    p = next_p;
                    r19 = p;
                }
                else if ( c >= 0x9 && c <= 0xa || c == 0xd || c == 0x20 ) {
                    s = 2;
                    p = next_p;
                    r18 = p;
                }
                else if ( c >= 0x0 && c <= 0x22 || c >= 0x24 && c <= 0x10ffff ) {
                    s = 1;
                    p = next_p;
                    r22 = p;
                }
                else
                    return false;
                break;
            case 1:
                if ( c >= 0x0 && c <= 0x8 || c >= 0x14 && c <= 0x1f || c >= 0x7f && c <= 0x9f || c >= 0x250 && c <= 0x20a2 || c >= 0x20b6 && c <= 0x10ffff ) {
                    s = 1;
                    p = next_p;
                    r22 = p;
                }
                else if ( c >= 0x9 && c <= 0xa || c == 0xd || c == 0x20 || c == 0x23 || c >= 0x2a && c <= 0x2b || c == 0x2f ) {
                    s = 33;
                    p = next_p;
                }
                else if ( c >= 0x0 && c <= 0x10ffff ) {
                    s = 34;
                    p = next_p;
                    r23 = p;
                }
                else
                    goto finish1;
                break;
            case 2:
                if ( c >= 0x9 && c <= 0xa || c == 0xd || c == 0x20 ) {
                    s = 31;
                    p = next_p;
                    r24 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 32;
                    p = next_p;
                }
                else
                    goto finish2;
                break;
            case 3:
                goto finish3;
            case 4:
                if ( c == 0x2f ) {
                    s = 28;
                    p = next_p;
                    r25 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 27;
                    p = next_p;
                }
                else
                    goto finish4;
                break;
            case 5:
                if ( c == 0x2f ) {
                    s = 9;
                    p = next_p;
                    r27 = p;
                }
                else if ( c == 0x2b ) {
                    s = 8;
                    p = next_p;
                    r26 = p;
                }
                else if ( c == 0x2a ) {
                    s = 7;
                    p = next_p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 6;
                    p = next_p;
                }
                else
                    goto finish5;
                break;
            case 6:
                goto finish6;
            case 7:
                if ( c == 0x2a ) {
                    s = 16;
                    p = next_p;
                }
                else if ( c >= 0x0 && c <= 0x8 || c >= 0x14 && c <= 0x1f || c >= 0x7f && c <= 0x9f || c >= 0x250 && c <= 0x20a2 || c >= 0x20b6 && c <= 0x10ffff ) {
                    s = 14;
                    p = next_p;
                }
                else if ( c >= 0x0 && c <= 0x10ffff ) {
                    s = 7;
                    p = next_p;
                }
                else
                    goto finish7;
                break;
            case 8:
                goto finish8;
            case 9:
                if ( c == 0xa ) {
                    s = 12;
                    p = next_p;
                }
                else if ( c >= 0x0 && c <= 0x8 || c >= 0x14 && c <= 0x1f || c >= 0x7f && c <= 0x9f || c >= 0x250 && c <= 0x20a2 || c >= 0x20b6 && c <= 0x10ffff ) {
                    s = 9;
                    p = next_p;
                    r27 = p;
                }
                else if ( c >= 0x0 && c <= 0x10ffff ) {
                    s = 11;
                    p = next_p;
                    r28 = p;
                }
                else
                    goto finish9;
                break;
            case 10:
                if ( c == 0xa ) {
                    s = 12;
                    p = next_p;
                }
                else if ( c >= 0x0 && c <= 0x8 || c >= 0x14 && c <= 0x1f || c >= 0x7f && c <= 0x9f || c >= 0x250 && c <= 0x20a2 || c >= 0x20b6 && c <= 0x10ffff ) {
                    s = 9;
                    p = next_p;
                    r27 = p;
                }
                else if ( c >= 0x0 && c <= 0x10ffff ) {
                    s = 11;
                    p = next_p;
                    r28 = p;
                }
                else
                    goto finish10;
                break;
            case 11:
                if ( c == 0xa ) {
                    s = 12;
                    p = next_p;
                    r27 = r28;
                }
                else if ( c >= 0x0 && c <= 0x8 || c >= 0x14 && c <= 0x1f || c >= 0x7f && c <= 0x9f || c >= 0x250 && c <= 0x20a2 || c >= 0x20b6 && c <= 0x10ffff ) {
                    s = 9;
                    p = next_p;
                    r27 = p;
                }
                else if ( c >= 0x0 && c <= 0x10ffff ) {
                    s = 11;
                    p = next_p;
                    r27 = r28;
                    r28 = p;
                }
                else
                    goto finish11;
                break;
            case 12:
                goto finish12;
            case 13:
                if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 8;
                    p = next_p;
                }
                else
                    goto finish13;
                break;
            case 14:
                if ( c == 0x2a ) {
                    s = 24;
                    p = next_p;
                }
                else if ( c >= 0x0 && c <= 0x10ffff ) {
                    s = 14;
                    p = next_p;
                }
                else
                    return false;
                break;
            case 15:
                if ( c == 0x2a ) {
                    s = 16;
                    p = next_p;
                }
                else if ( c >= 0x0 && c <= 0x8 || c >= 0x14 && c <= 0x1f || c >= 0x7f && c <= 0x9f || c >= 0x250 && c <= 0x20a2 || c >= 0x20b6 && c <= 0x10ffff ) {
                    s = 14;
                    p = next_p;
                }
                else if ( c >= 0x0 && c <= 0x10ffff ) {
                    s = 7;
                    p = next_p;
                }
                else
                    goto finish15;
                break;
            case 16:
                if ( c == 0x2f ) {
                    s = 17;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 6;
                    p = next_p;
                }
                else
                    goto finish16;
                break;
            case 17:
                if ( c == 0x2f ) {
                    s = 18;
                    p = next_p;
                    r29 = p;
                }
                else if ( c == 0x2a ) {
                    s = 16;
                    p = next_p;
                }
                else if ( c >= 0x0 && c <= 0x8 || c >= 0x14 && c <= 0x1f || c >= 0x7f && c <= 0x9f || c >= 0x250 && c <= 0x20a2 || c >= 0x20b6 && c <= 0x10ffff ) {
                    s = 14;
                    p = next_p;
                }
                else if ( c >= 0x0 && c <= 0x10ffff ) {
                    s = 7;
                    p = next_p;
                }
                else
                    return false;
                break;
            case 18:
                if ( c == 0x2a ) {
                    s = 20;
                    p = next_p;
                }
                else if ( c >= 0x0 && c <= 0x8 || c >= 0x14 && c <= 0x1f || c >= 0x7f && c <= 0x9f || c >= 0x250 && c <= 0x20a2 || c >= 0x20b6 && c <= 0x10ffff ) {
                    s = 14;
                    p = next_p;
                }
                else if ( c >= 0x0 && c <= 0x10ffff ) {
                    s = 18;
                    p = next_p;
                }
                else
                    goto finish18;
                break;
            case 19:
                if ( c == 0x2a ) {
                    s = 20;
                    p = next_p;
                }
                else if ( c >= 0x0 && c <= 0x8 || c >= 0x14 && c <= 0x1f || c >= 0x7f && c <= 0x9f || c >= 0x250 && c <= 0x20a2 || c >= 0x20b6 && c <= 0x10ffff ) {
                    s = 14;
                    p = next_p;
                }
                else if ( c >= 0x0 && c <= 0x10ffff ) {
                    s = 18;
                    p = next_p;
                }
                else
                    goto finish19;
                break;
            case 20:
                if ( c == 0x2f ) {
                    s = 22;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 21;
                    p = next_p;
                }
                else
                    goto finish20;
                break;
            case 21:
                goto finish21;
            case 22:
                if ( c == 0x2f ) {
                    s = 23;
                    p = next_p;
                    r30 = p;
                }
                else if ( c == 0x2a ) {
                    s = 20;
                    p = next_p;
                }
                else if ( c >= 0x0 && c <= 0x8 || c >= 0x14 && c <= 0x1f || c >= 0x7f && c <= 0x9f || c >= 0x250 && c <= 0x20a2 || c >= 0x20b6 && c <= 0x10ffff ) {
                    s = 14;
                    p = next_p;
                }
                else if ( c >= 0x0 && c <= 0x10ffff ) {
                    s = 18;
                    p = next_p;
                }
                else
                    return false;
                break;
            case 23:
                if ( c == 0x2a ) {
                    s = 20;
                    p = next_p;
                    r29 = r30;
                }
                else if ( c >= 0x0 && c <= 0x8 || c >= 0x14 && c <= 0x1f || c >= 0x7f && c <= 0x9f || c >= 0x250 && c <= 0x20a2 || c >= 0x20b6 && c <= 0x10ffff ) {
                    s = 14;
                    p = next_p;
                }
                else if ( c >= 0x0 && c <= 0x10ffff ) {
                    s = 18;
                    p = next_p;
                    r29 = r30;
                }
                else
                    goto finish23;
                break;
            case 24:
                if ( c == 0x2f ) {
                    s = 25;
                }
                else
                    return false;
                break;
            case 25:
                if ( c == 0x2f ) {
                    s = 26;
                    p = next_p;
                    r31 = p;
                }
                else if ( c == 0x2a ) {
                    s = 24;
                    p = next_p;
                }
                else if ( c >= 0x0 && c <= 0x10ffff ) {
                    s = 14;
                    p = next_p;
                }
                else
                    return false;
                break;
            case 26:
                if ( c == 0x2a ) {
                    s = 20;
                    p = next_p;
                    r29 = r31;
                }
                else if ( c >= 0x0 && c <= 0x8 || c >= 0x14 && c <= 0x1f || c >= 0x7f && c <= 0x9f || c >= 0x250 && c <= 0x20a2 || c >= 0x20b6 && c <= 0x10ffff ) {
                    s = 14;
                    p = next_p;
                }
                else if ( c >= 0x0 && c <= 0x10ffff ) {
                    s = 18;
                    p = next_p;
                    r29 = r31;
                }
                else
                    goto finish26;
                break;
            case 27:
                goto finish27;
            case 28:
                goto finish28;
            case 29:
                if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 28;
                    p = next_p;
                }
                else
                    goto finish29;
                break;
            case 30:
                if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 3;
                    p = next_p;
                }
                else
                    goto finish30;
                break;
            case 31:
                if ( c >= 0x9 && c <= 0xa || c == 0xd || c == 0x20 ) {
                    s = 31;
                    p = next_p;
                    r18 = r24;
                    r24 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 32;
                    p = next_p;
                    r18 = r24;
                }
                else
                    goto finish31;
                break;
            case 32:
                goto finish32;
            case 33:
                goto finish33;
            case 34:
                if ( c >= 0x0 && c <= 0x8 || c >= 0x14 && c <= 0x1f || c >= 0x7f && c <= 0x9f || c >= 0x250 && c <= 0x20a2 || c >= 0x20b6 && c <= 0x10ffff ) {
                    s = 1;
                    p = next_p;
                    r22 = p;
                }
                else if ( c >= 0x9 && c <= 0xa || c == 0xd || c == 0x20 || c == 0x23 || c >= 0x2a && c <= 0x2b || c == 0x2f ) {
                    s = 33;
                    p = next_p;
                    r22 = r23;
                }
                else if ( c >= 0x0 && c <= 0x10ffff ) {
                    s = 34;
                    p = next_p;
                    r22 = r23;
                    r23 = p;
                }
                else
                    goto finish34;
                break;
            default:
                assert(0);
        }
    }

    switch ( s )
    {
        case 1: finish1:
        case 33: finish33:
            match = input[0 .. r22];
            token = 5;
            break;
        case 2: finish2:
        case 32: finish32:
            match = input[0 .. r18];
            token = 0;
            break;
        case 3: finish3:
        case 30: finish30:
            match = input[0 .. r19];
            token = 7;
            break;
        case 4: finish4:
        case 27: finish27:
            match = input[0 .. r20];
            token = 6;
            break;
        case 5: finish5:
        case 6: finish6:
        case 7: finish7:
        case 15: finish15:
        case 16: finish16:
            match = input[0 .. r21];
            token = 8;
            break;
        case 8: finish8:
        case 13: finish13:
            match = input[0 .. r26];
            token = 3;
            break;
        case 9: finish9:
        case 10: finish10:
        case 12: finish12:
            match = input[0 .. r27];
            token = 1;
            break;
        case 11: finish11:
            match = input[0 .. r28];
            token = 1;
            break;
        case 18: finish18:
        case 19: finish19:
        case 20: finish20:
        case 21: finish21:
            match = input[0 .. r29];
            token = 2;
            break;
        case 23: finish23:
            match = input[0 .. r30];
            token = 2;
            break;
        case 26: finish26:
            match = input[0 .. r31];
            token = 2;
            break;
        case 28: finish28:
        case 29: finish29:
            match = input[0 .. r25];
            token = 4;
            break;
        case 31: finish31:
            match = input[0 .. r24];
            token = 0;
            break;
        case 34: finish34:
            match = input[0 .. r23];
            token = 5;
            break;
        default:
            return false;
    }

    return true;
}
// generated code end

#line 3079 "Config.d"
// Written in the D programming language

/*
 *  This file has been automatically generated by APaGeD v0.5 beta - Attributed Parser Generator for D.
 *
 *  Sections generated from custom input are marked as "generated code" and
 *  are subject to the terms and conditions stated in one of these sections.
 *  The remaining sections are part of the APaGeD package and subject
 *  to the terms and conditions of the corresponding license.
 *
 *  Attributed Parser Generator for D
 *  Copyright (c) 2007-2008 Jascha Wetzel. All rights reserved
 *  License: Artistic License 2.0
 */


version(Tango)
{
    import tango.text.convert.Layout;
    import Int = tango.text.convert.Integer;
    import tango.text.Util;
    import tango.util.log.Trace;

    private static Layout!(char) layout;

    static this()
    {
        layout = new Layout!(char);
    }

    string format(string fmt, ...)
    {
        return layout.convert(_arguments, _argptr, fmt);
    }

    static if ( !is(string) ) {
        private alias char[] string;
    }
}
else
{
    import std.string;
    import std.utf;
    debug import std.stdio;
}



/**************************************************************************************************
    Parser
**************************************************************************************************/

typedef uint Token;
alias Token Symbol;

const Token     EPSILON         = 1,
                ALTERN          = 2,
                EOS             = 3,
                FIRST_TOKEN     = 4,
                FIRST_NT        = 0x1000;

// generated code start
/*  Attributed Parser Generator for D
 *  Copyright (c) 2007 Jascha Wetzel. All rights reserved
 *  License: Artistic License 2.0, see license.txt
 */

const uint  MAX_INPUT_DUMP = 70,
            LR_STACK_RESERVE = 100,
            NODE_STACK_RESERVE = 20,
            BRANCH_STACK_RESERVE = 100;

/*******************************************************************************
    Stack based on dynamic array
*******************************************************************************/
struct Stack(T)
{
    size_t  _top;
    T[]     stack;

    void push(T v)
    {
        if ( _top >= stack.length )
            stack.length = stack.length*2+1;
        stack[_top] = v;
        ++_top;
    }

    void push(T[] vs)
    {
        size_t end = _top+vs.length;
        if ( end > stack.length )
            stack.length = end*2;
        stack[_top..end] = vs;
        _top = end;
    }
    alias push opCatAssign;

    void pop(size_t num)
    {
        assert(_top>=num, __FILE__~"("~Int.toString(__LINE__)~")");
        if ( num >= _top )
            _top = 0;
        else
            _top -= num;
    }

    T pop()
    {
        assert(_top>0, __FILE__~"("~Int.toString(__LINE__)~")");
        return stack[--_top];
    }

    T* popPtr()
    {
        assert(_top>0, __FILE__~"("~Int.toString(__LINE__)~")");
        return &stack[--_top];
    }

    T top()
    {
        assert(_top>0, __FILE__~"("~Int.toString(__LINE__)~")");
        return stack[_top-1];
    }

    T* topPtr()
    {
        assert(_top>0, __FILE__~"("~Int.toString(__LINE__)~")");
        return &stack[_top-1];
    }

    bool empty()
    {
        return _top == 0;
    }

    void clear()
    {
        _top = 0;
    }

    size_t length()
    {
        return _top;
    }

    T[] array()
    {
        return stack[0.._top];
    }

    Stack dup()
    {
        Stack s;
        s._top = _top;
        s.stack = stack.dup;
        return s;
    }

    void free()
    {
        _top = 0;
        delete stack;
    }
}

/**************************************************************************************************
    Information about rules needed for reduction and error handling
**************************************************************************************************/
align(1) struct RuleInfo
{
    bool    ast_node;
    uint    symbol_count,
            nt_count,
            nt_index;
    Symbol[]  symbols;
}

/**************************************************************************************************
    Information about LALR(1) entries needed for debugging
**************************************************************************************************/
align(1) struct EntryInfo
{
    uint    rule_index,
            pos;
}

/**************************************************************************************************
    Exception thrown on parser error
**************************************************************************************************/
class ParserException : Exception
{
    uint    line,
            column;
    string  filename,
            error_message,
            detail;

    this(uint line_, uint column_, string fname, string msg, string dtl="detail")
    {
        version(Tango)
            super(format("{}({}:{}): {}{}", fname, line_, column_, msg, dtl !is null?"\n"~dtl:""));
        else
            super(format("%s(%d:%d): %s%s", fname, line_, column_, msg, dtl !is null?"\n"~dtl:""));
        filename = fname;
        error_message = msg;
        line = line_;
        column = column_;
        detail = dtl;
    }
}

/**************************************************************************************************
    Wraps instantiation of the GLR parser class and the parse call.
**************************************************************************************************/
bool parse(string filename, string input, out SyntaxTree root, bool detailed=false, bool recover=false, uint tab_width=4)
{
    GLRParser   g, w;
    static if ( is(WhitespaceGrammar : GLRParser) )
        w = new WhitespaceGrammar;
    g = new MainGrammar(w, tab_width);
    bool succ = g.parse(filename, input, root, detailed, recover);
    return succ;
}

/**************************************************************************************************
    GLR parser
**************************************************************************************************/
abstract class GLRParser
{
    struct LRState
    {
        uint    index,
                line,
                column;
    }

    struct Node
    {
        SyntaxTree  node;
        bool        sync;
    }

    struct LRBranch
    {
        Stack!(LRState) stack;
        Stack!(Node)    node_stack;
        string          input,
                        lookahead,
                        lookahead_ws;
        uint            line,
                        column,
                        symbol;
        bool            fatal_errors;
        uint            action;
        version(ProfileConflicts)
            uint            last_conflict;
    }

    string          filename_;
    uint            tab_width_;

    // operational variables
    string              match_,
                        match_ws_,
                        lookahead_,
                        lookahead_ws_;
    SyntaxTree          syntax_root_;
    ubyte[]             memory_pool_;
    size_t              pool_top_;
    Stack!(LRState)     stack_;
    Stack!(Node)        node_stack_;
    Stack!(LRBranch)    branch_stack_;
    ParserException[]   recovered_errors_;
    bool                recover_from_errors_,
                        detailed_errors_;

    version(ProfileConflicts) {
        uint[uint]      rr_conflict_counts_,
                        sr_conflict_counts_,
                        shift_failed_counts_,
                        reduce_failed_counts_;
        uint            branch_stack_max_;
    }

    // grammar data
    GLRParser       ws_parser_;
    uint            first_nt_;
    RuleInfo[]      rule_infos_;
    string[][]      error_message_lists_;
    string[]        nt_names_,
                    lexeme_names_;
    EntryInfo[][]   entry_infos_;
    ClassInfo[]     syntax_node_cinfos_;

    /**************************************************************************************************

    **************************************************************************************************/
    this(GLRParser ws, uint tabw)
    {
        ws_parser_ = ws;
        tab_width_ = tabw;
        stack_.stack.length = LR_STACK_RESERVE;
        node_stack_.stack.length = NODE_STACK_RESERVE;
        branch_stack_.stack.length = BRANCH_STACK_RESERVE;
    }

    /**************************************************************************************************
        Gets overridden with a first-longest-match lexical analizer.
    **************************************************************************************************/
    bool function(string, out uint, out string) lexer;

    /**************************************************************************************************
        Gets overridden with the main parser function.
    **************************************************************************************************/
    bool parse(string input) { return false; }
    bool parseWS(ref string input) { return false; }

    /**************************************************************************************************

    **************************************************************************************************/
    abstract bool isErrorSynced(uint state);

    /**************************************************************************************************

    **************************************************************************************************/
    T APDmin(T)(T a, T b) { return a<b?a:b; }
    abstract uint[] lookaheadForNT(uint nt_index, uint state);

    /**************************************************************************************************
        Update line and column counter according to str
    **************************************************************************************************/
    void countLocation(string str, ref uint line, ref uint col)
    {
        dchar linefeed;
        for ( size_t p; p < str.length; )
        {
            dchar c = cast(dchar)str[p];
            if ( c & 0x80 )
                c = decode(str, p);
            else
                ++p;

            switch ( c )
            {
                case '\n':
                case '\r':
                    if ( linefeed == dchar.init || linefeed == c ) {
                        ++line;
                        col = 1;
                        linefeed = c;
                    }
                    else
                        linefeed = dchar.init;
                    break;
                case '\t':
                    col += tab_width_-(col-1)%tab_width_;
                    linefeed = dchar.init;
                    break;
                default:
                    ++col;
                    linefeed = dchar.init;
                    break;
            }
        }
    }

    /**************************************************************************************************
        Initiates the parse call.
    **************************************************************************************************/
    final bool parse(string fname, string input, out SyntaxTree root, bool detailed=false, bool recover=false)
    {
        filename_ = fname;
        recover_from_errors_ = recover;
        detailed_errors_ = detailed;

        stack_.clear;
        node_stack_.clear;
        branch_stack_.clear;
        pool_top_ = 0;
        memory_pool_ = null;
        recovered_errors_ = null;

        if ( input.length > 1 )
        {
            if ( input[0 .. 2] == "\xfe\xff" ) {
                // UTF-16BE
                input = input[2 .. $];
            }
            else if ( input[0 .. 2] == "\xff\xfe" )
            {
                if ( input.length > 3 && input[2 .. 4] == "\x00\x00" ) {
                    // UTF-32LE
                    input = input[4 .. $];
                }
                else {
                    // UTF-16LE
                    input = input[2 .. $];
                }
            }
            else if ( input.length > 2 && input[0 .. 3] == "\xef\xbb\xbf" ) {
                // UTF-8
                input = input[3 .. $];
            }
            else if ( input.length > 3 && input[0 .. 4] == "\x00\x00\xfe\xff" ) {
                // UTF-32BE
                input = input[4 .. $];
            }
            else if ( input[0] > 0x7f )
                return false;
        }

        stack_ ~= LRState(0, 1, 1);
        if ( parse(input) )
        {
            if ( syntax_root_ !is null )
            {
                root = syntax_root_;
                debug
                {
                    Stack!(SyntaxTree) st;
                    st.push(root);
                    while ( !st.empty )
                    {
                        SyntaxTree pn = st.pop;
                        foreach ( c; pn._ST_children ) {
                            c.parent = pn;
                            st.push(c);
                        }
                    }
                }
            }
            return true;
        }
        return false;
    }

    /**************************************************************************************************
        Create a node for the syntax tree. Used by the main parse function.
    **************************************************************************************************/
    void createNode(uint line, uint column, uint rule_index, uint nt_count, uint nt_index)
    {
/*
        if ( pool_top >= syntax_tree_pool.length )
            syntax_tree_pool.length = syntax_tree_pool.length*2+1;
        auto pn = &syntax_tree_pool[pool_top];
        ++pool_top;
*/
        auto pn = cast(SyntaxTree)syntax_node_cinfos_[nt_index].create();
        pn._ST_rule = rule_index;
        pn._ST_line_number = line;
        pn._ST_column_number = column;
        debug pn._ST_node_name = nt_names_[nt_index];

        if ( nt_count > 0 )
        {
            pn._ST_children.length = nt_count;
            foreach ( i, n; node_stack_.array[$-nt_count .. $] )
                pn._ST_children[i] = n.node;
            node_stack_.pop(nt_count);
        }
        else {
            pn._ST_match = match_;
            pn._ST_match_ws = match_ws_;
        }
        node_stack_ ~= Node(pn, false);
    }

    /**************************************************************************************************

    **************************************************************************************************/
    string ruleToString(RuleInfo* ri, int pos)
    {
        version(Tango)
            string str = format("{} ->", nt_names_[ri.nt_index]);
        else
            string str = format("%s ->", nt_names_[ri.nt_index]);

        foreach ( i, s; ri.symbols )
        {
            string name;
            if ( s == ALTERN )
                name = "ALTERN";
            else if ( s < FIRST_NT )
                name = lexeme_names_[s-EOS];
            else
                name = nt_names_[s-FIRST_NT];
            if ( i == pos )
                str ~= " .";
            version(Tango)
                str ~= format(" {}", name);
            else
                str ~= format(" %s", name);
        }
        if ( pos == ri.symbols.length )
            str ~= " .";
        return str;
    }

    /**************************************************************************************************
        Issue an error. Used by the main parse function.
    **************************************************************************************************/
    void error(string input, uint line, uint column, uint error_list, uint symbol, bool fatal=true)
    {
        // collect explicit error messages
        string errors;
        foreach ( i, err; error_message_lists_[error_list] )
        {
            if ( i > 0 )
                errors ~= "\n";
            errors ~= err;
        }

        // construct automatic error message
        // if no explicit error message available
        if ( errors.length == 0 )
        {
            bool[string] expected_symbols;
            EntryInfo[] eis = entry_infos_[stack_.top.index];
            foreach ( ei; eis )
            {
                RuleInfo* ri = &rule_infos_[ei.rule_index];
                if ( ei.pos < ri.symbols.length )
                {
                    auto s = ri.symbols[ei.pos];
                    if ( s < FIRST_NT )
                        expected_symbols["\""~lexeme_names_[s-EOS]~"\""] = true;
                    else
                        expected_symbols[nt_names_[s-FIRST_NT]] = true;
                }
                else
                {
                    foreach ( token; lookaheadForNT(ri.nt_index, stack_.top.index) ) {
                        assert(token < FIRST_NT, __FILE__~"("~Int.toString(__LINE__)~")");
                        expected_symbols["\""~lexeme_names_[token-EOS]~"\""] = true;
                    }
                }
            }

            string expected_str;
            auto last = expected_symbols.length-1;
            foreach ( i, symname; expected_symbols.keys )
            {
                if ( i > 0 )
                {
                    if ( i == last )
                        expected_str ~= " or ";
                    else
                        expected_str ~= ", ";
                }
                expected_str ~= symname;
            }
            version(Tango)
                errors = format("found \"{}\", expected {}", lookahead_, expected_str);
            else
                errors = format("found \"%s\", expected %s", lookahead_, expected_str);
        }

        // construct detail message
        string detail;
        if ( detailed_errors_ )
        {
            string          lr_stack;
            foreach ( st; stack_.array[1..$] )
            {
                version(Tango)
                    lr_stack ~= format("---- State {}{} ({}:{}) ----\n", st.index, isErrorSynced(st.index)?"*":"", st.line, st.column);
                else
                    lr_stack ~= format("---- State %d%s (%d:%d) ----\n", st.index, isErrorSynced(st.index)?"*":"", st.line, st.column);
                EntryInfo[] eis = entry_infos_[st.index];
                foreach ( ei; eis )
                    lr_stack ~= ruleToString(&rule_infos_[ei.rule_index], ei.pos)~"\n";
            }

            string node_stack_str;
            foreach ( i, n; node_stack_.array )
            {
                if ( i > 0 )
                    node_stack_str ~= " ";
                node_stack_str ~= nt_names_[rule_infos_[n.node._ST_rule].nt_index];
                if ( n.sync )
                    node_stack_str ~= "*";
            }

            version(Tango)
                detail = format("input: {}\nlookahead: {}\nlexeme: {}\nAST node stack:\n{}\nLR stack:\n{}",
                    substitute(substitute(input[0..$>MAX_INPUT_DUMP?MAX_INPUT_DUMP:$], "\r", "\\r"), "\n", "\\n"),
                    lookahead_, lexeme_names_[symbol-EOS],
                    node_stack_str, lr_stack
                );
            else
                detail = format("input: %s\nlookahead: %s\nlexeme: %s\nAST node stack:\n%s\nLR stack:\n%s",
                    replace(replace(input[0..$>MAX_INPUT_DUMP?MAX_INPUT_DUMP:$], "\r", "\\r"), "\n", "\\n"),
                    lookahead_, lexeme_names_[symbol-EOS],
                    node_stack_str, lr_stack
                );
        }

        // throw error
        if ( fatal ) {
            version(Tango) Trace.formatln("");
            throw new ParserException(line, column-lookahead_.length, filename_, errors, detail);
        }
        else
        {
            version(Tango)
                debug(nonfatal) Trace.formatln("\n{}({}:{}): {}\n{}", filename_, line, column-lookahead_.length, errors, detail);
            else
                debug(nonfatal) writefln("\n%s(%d:%d): %s\n%s", filename_, line, column-lookahead_.length, errors, detail);
        }
    }
}

/**************************************************************************************************
    Generated parsers
**************************************************************************************************/
class MainGrammar : public GLRParser
{
    const ushort[]  action_base_ =
    [
        0,0,21,42,1,50,0,7,39,0,71,2,2,75,4,89,101,105,6,68,8,112,9,118,122,127,131,8,143,11,21,148,
        82,83,28,166,30,184,46,201,35,51,124,57,205,211,224,237,250,267,271,138,283,287,290,307,
        313,327,333,91,339,70,158,345,80,129,358,371,384,84,397,109,418,99,121,422,128,436,448,460,
        122,142,464,157,478,490,502,514,185,145,212,278,526,294,530,171,544,177,556,189,568,191,
        195
    ];
    const ubyte[]  action_check_ =
    [
        0,0,0,6,9,12,0,0,14,0,18,7,27,7,7,29,7,0,4,11,1,2,2,2,7,20,22,2,2,2,2,30,34,2,2,2,2,2,2,2,2,
        2,3,3,3,8,8,36,3,3,38,3,40,5,41,5,8,5,5,3,5,43,5,5,5,5,5,5,5,5,5,10,10,10,19,19,10,10,10,
        13,10,13,13,61,13,19,32,33,10,15,15,15,13,64,15,15,15,69,15,32,33,16,16,16,59,59,15,16,16,
        17,16,17,17,71,17,21,73,21,16,21,21,23,17,23,74,24,23,24,42,21,24,25,76,25,25,26,25,26,26,
        80,26,42,65,65,25,81,51,28,26,28,28,31,28,51,51,51,51,51,51,31,28,83,89,31,31,31,31,31,31,
        35,62,62,62,35,35,95,35,97,35,35,35,35,35,35,35,35,35,37,88,99,88,101,37,88,37,102,37,37,
        37,37,37,37,37,37,37,39,103,39,39,44,39,44,44,103,44,90,103,90,39,45,90,103,44,45,45,45,45,
        45,45,45,45,45,46,103,103,103,46,46,46,46,46,46,46,46,46,47,103,103,103,47,47,47,47,47,47,
        47,47,47,48,103,103,103,48,48,48,48,48,48,48,48,48,49,103,49,49,50,49,50,50,103,50,91,103,
        91,49,103,91,52,50,52,52,53,52,53,53,103,53,93,54,93,52,103,93,103,53,54,54,54,54,54,54,55,
        103,55,55,103,55,103,103,103,103,56,103,103,55,56,56,56,56,56,56,56,56,56,57,57,103,103,
        103,57,57,57,57,57,57,57,57,57,58,58,58,58,58,58,60,60,60,60,60,60,63,63,63,63,63,63,66,
        103,103,103,66,66,66,66,66,66,66,66,66,67,103,103,103,67,67,67,67,67,67,67,67,67,68,103,
        103,103,68,68,68,68,68,68,68,68,68,70,103,103,103,70,70,70,70,70,70,70,70,70,72,72,72,103,
        72,72,72,72,75,72,75,75,103,75,103,103,103,72,77,77,77,75,77,77,77,77,103,77,103,103,78,78,
        78,103,78,77,78,78,103,78,103,103,79,79,79,103,79,78,79,79,82,79,82,82,103,82,103,103,103,
        79,84,84,84,82,84,84,84,84,103,84,103,103,85,85,85,103,85,84,85,85,103,85,103,103,86,86,86,
        103,86,85,86,86,103,86,103,103,87,87,87,103,87,86,87,87,103,87,103,103,92,92,92,103,92,87,
        92,92,94,92,94,94,103,94,103,103,103,92,96,96,96,94,103,103,96,96,103,96,103,103,98,98,98,
        103,103,96,98,98,103,98,103,103,100,100,100,103,103,98,100,100,103,100,103,103,103,103,103,
        103,103,100
    ];
    const ushort[]  action_data_ =
    [
        259,129,132,135,138,141,282,282,143,136,263,265,278,282,282,279,136,282,133,133,130,308,308,
        308,0,133,133,308,308,308,308,159,294,308,308,308,308,308,308,308,308,308,259,129,132,281,
        281,133,282,282,167,136,133,305,170,305,281,305,305,282,305,172,305,305,305,305,305,305,
        305,305,305,262,262,262,148,217,139,262,262,265,262,282,282,293,136,133,295,295,262,262,
        262,262,0,193,139,262,262,198,262,133,133,261,261,261,292,188,262,261,261,265,261,282,282,
        200,136,270,133,270,261,150,270,269,0,269,203,153,269,208,295,133,214,280,205,282,282,280,
        136,282,282,133,136,133,291,291,0,210,180,280,0,282,282,160,136,173,174,133,175,176,130,
        168,0,212,133,173,174,133,175,176,130,304,191,290,290,164,304,264,304,256,304,304,304,304,
        304,304,304,304,304,303,268,258,268,257,303,268,303,3,303,303,303,303,303,303,303,303,303,
        285,384,285,285,286,285,286,286,384,286,272,384,272,285,296,272,384,286,296,296,296,296,
        296,296,296,296,296,297,384,384,384,297,297,297,297,297,297,297,297,297,306,384,384,384,
        306,306,306,306,306,306,306,306,306,307,384,384,384,307,307,307,307,307,307,307,307,307,
        283,384,283,283,287,283,287,287,384,287,153,384,208,283,384,214,1,287,1,1,289,1,289,289,
        384,289,271,183,271,1,384,271,384,289,173,174,133,175,176,130,288,384,288,288,384,288,384,
        384,384,384,298,384,384,288,298,298,298,298,298,298,298,298,298,164,304,384,384,384,2,304,
        304,304,304,304,304,304,304,173,174,133,175,176,130,173,174,133,175,176,130,173,174,133,
        175,176,130,299,384,384,384,299,299,299,299,299,299,299,299,299,300,384,384,384,300,300,
        300,300,300,300,300,300,300,302,384,384,384,302,302,302,302,302,302,302,302,302,301,384,
        384,384,301,301,301,301,301,301,301,301,301,277,277,277,384,277,201,277,277,280,277,282,
        282,384,136,384,384,384,277,277,277,277,0,277,201,277,277,384,277,384,384,276,276,276,384,
        276,277,276,276,384,276,384,384,273,273,273,384,273,276,273,273,280,273,282,282,384,136,
        384,384,384,273,277,277,277,0,277,201,277,277,384,277,384,384,274,274,274,384,274,277,274,
        274,384,274,384,384,275,275,275,384,275,274,275,275,384,275,384,384,266,266,266,384,266,
        275,266,266,384,266,384,384,267,267,267,384,267,266,267,267,265,267,282,282,384,136,384,
        384,384,267,260,260,260,0,384,384,260,260,384,260,384,384,259,129,132,384,384,260,282,282,
        384,136,384,384,259,129,132,384,384,282,282,282,384,136,384,384,384,384,384,384,384,282
    ];
    const ubyte[]  goto_base_ =
    [
        0,0,0,2,0,0,0,5,0,0,3,2,0,22,0,5,0,24,0,11,10,26,17,0,4,40,43,0,56,0,0,51,65,69,0,0,19,0,0,
        0,20,0,75,0,0,0,0,0,0,0,0,79,0,0,89,0,0,0,98,0,107,0,0,116,0,0,0,0,0,0,0,0,5,37,0,135,0,6,
        0,0,59,0,138,0,10,0,0,0,0,27,0,41,0,0,148,0,0,0,160,0,168,0,0
    ];
    const ubyte[]  goto_check_ =
    [
        0,0,3,3,0,10,3,15,7,7,0,24,3,72,77,7,7,19,84,4,11,11,1,7,7,13,13,17,17,20,19,21,13,13,17,17,
        22,36,36,40,13,13,17,17,25,21,89,26,91,25,25,25,26,26,26,73,73,103,25,25,28,26,26,31,31,28,
        28,28,31,31,31,31,31,31,28,28,32,80,80,103,33,32,103,32,32,33,42,33,33,103,103,42,51,42,42,
        103,51,51,51,51,51,51,54,103,103,103,54,54,54,54,54,54,58,58,103,58,58,58,58,58,58,60,60,
        103,60,60,60,60,60,60,63,63,103,63,63,63,63,63,63,75,103,103,82,103,75,75,75,82,82,82,103,
        94,94,75,75,103,82,82,94,94,98,98,103,103,98,103,94,94,100,100,98,103,100,103,103,103,103,
        103,100
    ];
    const ubyte[]  goto_data_ =
    [
        102,98,97,98,100,96,100,16,9,17,19,87,19,79,78,19,94,91,85,6,12,35,3,30,35,14,17,18,17,21,
        93,24,19,94,19,94,23,37,35,41,30,35,30,35,26,88,90,26,92,71,19,28,27,19,28,74,35,103,30,35,
        26,30,35,49,50,29,19,28,51,56,57,66,67,68,30,35,33,81,35,103,33,38,103,30,35,34,33,30,35,
        103,103,43,53,30,35,103,54,56,57,66,67,68,53,103,103,103,54,56,57,66,67,68,59,69,103,62,56,
        57,66,67,68,59,61,103,62,56,57,66,67,68,59,64,103,62,56,57,66,67,68,26,103,103,26,103,76,
        19,28,83,19,28,103,95,17,30,35,103,30,35,19,94,99,98,103,103,100,103,30,35,101,98,19,103,
        100,103,103,103,103,103,19
    ];

    debug(parser) string indent_;

    this(GLRParser ws=null, uint tab_width=4)
    {
        super(ws, tab_width);
        lexer = &mainLexer;
        first_nt_ = 24;
        nt_names_ =
        [
            "Document","WidgetTypeSpecification","WidgetTypeExtraSpecification",
            "WidgetTypeSpecBody","SubWidget","SubWidgetName","NonEmptySubWidgetName",
            "WidgetSpecification","WidgetExtraSpecification","WidgetBody","LayoutAttribs",
            "PropertyAssignment","PropertyValue","ComplexValueSpec","FuncArg","FuncArgList",
            "PropertyBlock","SimpleValue","PropertyName","Identifier","Number",
            "FloatingPointNumber","StringSpec","!LRstart"
        ];
        lexeme_names_ =
        [
            "EOS","import","widget","\\{","\\}","@","new","\\.",";","\\[[^\\]]+\\]","=","graphic",
            "\\(","\\)",",","true","false","[a-zA-Z_][0-9a-zA-Z_]*","-?[0-9][0-9_]*",
            "(-?[0-9][0-9_]*\\.[0-9][0-9_]*)|(-?\\.[0-9][0-9_]*)","\"([^\"]|(\\\\\"))*\""
        ];
        entry_infos_ =
        [
            cast(EntryInfo[])[EntryInfo(3,0),EntryInfo(26,0)],[EntryInfo(0,1)],[EntryInfo(52,1)],[EntryInfo(0,2)
            ,EntryInfo(3,0),EntryInfo(26,0)],[EntryInfo(4,1)],[EntryInfo(49,1)],[EntryInfo(4,2)],[EntryInfo(4,3)
            ,EntryInfo(9,0),EntryInfo(26,0)],[EntryInfo(25,1)],[EntryInfo(4,4)],[EntryInfo(4,5),EntryInfo(6,0)],[
            EntryInfo(5,1)],[EntryInfo(5,2)],[EntryInfo(5,3),EntryInfo(9,0),EntryInfo(26,0)],[EntryInfo(5,4)],[
            EntryInfo(5,5),EntryInfo(6,0)],[EntryInfo(5,6)],[EntryInfo(7,1),EntryInfo(9,0),EntryInfo(26,0)],[
            EntryInfo(7,2)],[EntryInfo(10,1),EntryInfo(11,1)],[EntryInfo(10,2)],[EntryInfo(10,3),EntryInfo(14,0)],[
            EntryInfo(13,1)],[EntryInfo(13,2)],[EntryInfo(10,4)],[EntryInfo(17,1),EntryInfo(24,0),EntryInfo(26,0)],[
            EntryInfo(22,1),EntryInfo(24,0),EntryInfo(26,0)],[EntryInfo(22,2)],[EntryInfo(23,1),EntryInfo(24,0)
            ,EntryInfo(26,0)],[EntryInfo(23,2)],[EntryInfo(27,1)],[EntryInfo(27,2)],[EntryInfo(29,1)
            ,EntryInfo(39,0)],[EntryInfo(38,1),EntryInfo(39,0)],[EntryInfo(38,2)],[EntryInfo(47,1),EntryInfo(48,1)],[
            EntryInfo(47,2)],[EntryInfo(47,3)],[EntryInfo(29,2)],[EntryInfo(29,3)],[EntryInfo(30,1)],[
            EntryInfo(30,2)],[EntryInfo(30,3),EntryInfo(39,0)],[EntryInfo(30,4)],[EntryInfo(30,5)],[
            EntryInfo(40,1)],[EntryInfo(41,1)],[EntryInfo(50,1)],[EntryInfo(51,1)],[EntryInfo(27,3)],[
            EntryInfo(31,1)],[EntryInfo(28,1),EntryInfo(32,1),EntryInfo(33,1)],[EntryInfo(28,2),EntryInfo(32,2)],[
            EntryInfo(33,2)],[EntryInfo(32,1),EntryInfo(33,1)],[EntryInfo(32,2)],[EntryInfo(42,1)],[
            EntryInfo(45,1),EntryInfo(47,1),EntryInfo(48,1)],[EntryInfo(45,2)],[EntryInfo(36,1),EntryInfo(37,1)],[
            EntryInfo(37,2)],[EntryInfo(37,3)],[EntryInfo(34,1),EntryInfo(35,1)],[EntryInfo(35,2)],[
            EntryInfo(35,3)],[EntryInfo(35,4)],[EntryInfo(43,1)],[EntryInfo(44,1)],[EntryInfo(46,1)],[
            EntryInfo(45,3)],[EntryInfo(45,4)],[EntryInfo(17,2)],[EntryInfo(17,3),EntryInfo(21,0)],[
            EntryInfo(20,1)],[EntryInfo(20,2)],[EntryInfo(20,3),EntryInfo(24,0),EntryInfo(26,0)],[EntryInfo(20,4)],[
            EntryInfo(20,5),EntryInfo(21,0)],[EntryInfo(20,6)],[EntryInfo(17,4)],[EntryInfo(18,1)],[
            EntryInfo(18,2)],[EntryInfo(18,3),EntryInfo(24,0),EntryInfo(26,0)],[EntryInfo(18,4)],[EntryInfo(18,5)
            ,EntryInfo(21,0)],[EntryInfo(18,6)],[EntryInfo(19,1)],[EntryInfo(10,5)],[EntryInfo(12,1)],[
            EntryInfo(16,1)],[EntryInfo(16,2)],[EntryInfo(11,2)],[EntryInfo(11,3)],[EntryInfo(15,1)],[
            EntryInfo(8,1),EntryInfo(9,0),EntryInfo(26,0)],[EntryInfo(8,2)],[EntryInfo(4,6)],[EntryInfo(0,3)],[
            EntryInfo(2,1),EntryInfo(3,0),EntryInfo(26,0)],[EntryInfo(2,2)],[EntryInfo(1,1),EntryInfo(3,0)
            ,EntryInfo(26,0)],[EntryInfo(1,2)],[EntryInfo(53,1)]
        ];
        rule_infos_ =
        [
            RuleInfo(true,3,2,0,[ 4, 4118, 4096 ]),RuleInfo(true,2,2,0,[ 4100, 4096 ]),
            RuleInfo(true,2,2,0,[ 4097, 4096 ]),RuleInfo(true,0,0,0,[  ]),
            RuleInfo(true,6,3,1,[ 5, 4115, 6, 4099, 7, 4098 ]),
            RuleInfo(true,6,3,2,[ 8, 4114, 6, 4099, 7, 4098 ]),RuleInfo(true,0,0,2,[  ]),
            RuleInfo(true,2,2,3,[ 4100, 4099 ]),RuleInfo(true,2,2,3,[ 4107, 4099 ]),RuleInfo(true,0,0,3,[  ]),
            RuleInfo(true,5,4,4,[ 4106, 9, 4115, 4101, 4103 ]),RuleInfo(true,3,3,4,[ 4106, 4102, 4103 ]),
            RuleInfo(true,1,1,5,[ 4115 ]),RuleInfo(true,2,1,5,[ 10, 4115 ]),RuleInfo(true,0,0,5,[  ]),
            RuleInfo(true,1,1,6,[ 4115 ]),RuleInfo(true,2,1,6,[ 10, 4115 ]),
            RuleInfo(true,4,2,7,[ 6, 4105, 7, 4104 ]),RuleInfo(true,6,3,7,[ 8, 4114, 6, 4105, 7, 4104 ]),
            RuleInfo(true,1,0,7,[ 11 ]),RuleInfo(true,6,3,8,[ 8, 4114, 6, 4105, 7, 4104 ]),
            RuleInfo(true,0,0,8,[  ]),RuleInfo(true,2,2,9,[ 4100, 4105 ]),RuleInfo(true,2,2,9,[ 4107, 4105 ]),
            RuleInfo(true,0,0,9,[  ]),RuleInfo(true,1,0,10,[ 12 ]),RuleInfo(true,0,0,10,[  ]),
            RuleInfo(true,3,2,11,[ 4114, 13, 4108 ]),RuleInfo(true,2,1,12,[ 4113, 11 ]),
            RuleInfo(true,3,1,12,[ 6, 4112, 7 ]),RuleInfo(true,5,2,12,[ 14, 4115, 6, 4112, 7 ]),
            RuleInfo(true,1,1,12,[ 4109 ]),RuleInfo(true,2,1,13,[ 4113, 11 ]),
            RuleInfo(true,2,2,13,[ 4113, 4109 ]),RuleInfo(true,1,1,14,[ 4113 ]),
            RuleInfo(true,4,2,14,[ 4113, 15, 4111, 16 ]),RuleInfo(true,1,1,15,[ 4110 ]),
            RuleInfo(true,3,2,15,[ 4110, 17, 4111 ]),RuleInfo(true,2,2,16,[ 4107, 4112 ]),
            RuleInfo(true,0,0,16,[  ]),RuleInfo(true,1,0,17,[ 18 ]),RuleInfo(true,1,0,17,[ 19 ]),
            RuleInfo(true,1,1,17,[ 4114 ]),RuleInfo(true,1,1,17,[ 4116 ]),RuleInfo(true,1,1,17,[ 4117 ]),
            RuleInfo(true,4,2,17,[ 4115, 15, 4111, 16 ]),RuleInfo(true,1,1,17,[ 4118 ]),
            RuleInfo(true,3,2,18,[ 4115, 10, 4114 ]),RuleInfo(true,1,1,18,[ 4115 ]),
            RuleInfo(true,1,0,19,[ 20 ]),RuleInfo(true,1,0,20,[ 21 ]),RuleInfo(true,1,0,21,[ 22 ]),
            RuleInfo(true,1,0,22,[ 23 ]),RuleInfo(true,1,1,23,[ 4096 ])
        ];
        syntax_node_cinfos_ =
        [
            SyntaxTree.classinfo,SyntaxTree.classinfo,SyntaxTree.classinfo,SyntaxTree.classinfo,
            SyntaxTree.classinfo,SyntaxTree.classinfo,SyntaxTree.classinfo,SyntaxTree.classinfo,
            SyntaxTree.classinfo,SyntaxTree.classinfo,SyntaxTree.classinfo,SyntaxTree.classinfo,
            SyntaxTree.classinfo,SyntaxTree.classinfo,SyntaxTree.classinfo,SyntaxTree.classinfo,
            SyntaxTree.classinfo,SyntaxTree.classinfo,SyntaxTree.classinfo,SyntaxTree.classinfo,
            SyntaxTree.classinfo,SyntaxTree.classinfo,SyntaxTree.classinfo,SyntaxTree.classinfo
        ];
        error_message_lists_ = [
            cast(string[])null
        ];
    }

    uint[] lookaheadForNT(uint nt_index, uint state)
    {
        uint[] tokens;
        auto b = action_base_[state];
        auto m = APDmin(action_check_.length, cast(size_t)b+first_nt_);
        foreach ( i, check; action_check_[b .. m] )
        {
            if ( check == state && (action_data_[b+i] & 384) == 256 )
                tokens ~= i+EOS;
        }
        return tokens;
    }

    override bool isErrorSynced(uint state)
    {
        switch ( state )
        {
            case 0:
                return true;
            default:
                break;
        }
        return false;
    }

    override bool parse(string input)
    {
        debug(parser) indent_ ~= " ";


        bool    fatal_errors = true;
        uint    line = 1,
                column = 1,
                symbol;

        void reduce(uint rule)
        {
            version(Tango)
                debug(parser) Trace.format("{}reduce {} {}\n", indent_, rule, ruleToString(&rule_infos_[rule], -1));
            else
                debug(parser) writefln("%sreduce %d %s", indent_, rule, ruleToString(&rule_infos_[rule], -1));
            auto ri = &rule_infos_[rule];
            uint    reduce_line,
                    reduce_column;
            if ( ri.symbol_count > 0 ) {
                reduce_line = stack_.array[$-ri.symbol_count].line;
                reduce_column = stack_.array[$-ri.symbol_count].column;
                stack_.pop(ri.symbol_count);
            }
            else {
                reduce_line = stack_.top.line;
                reduce_column = stack_.top.column;
            }

            auto b = goto_base_[stack_.top.index];
            b += ri.nt_index;
            debug(parser)
            {
                if ( b < goto_check_.length && goto_check_[b] == stack_.top.index ) {
                    stack_ ~= LRState(goto_data_[b], reduce_line, reduce_column);

                version(Tango)
                    Trace.format("{}goto {}\n", indent_, stack_.top.index);
                else
                    writefln("%sgoto %d", indent_, stack_.top.index);
                }
                else
                    assert(0, __FILE__~"("~Int.toString(__LINE__)~")");
            }
            else
                stack_ ~= LRState(goto_data_[b], reduce_line, reduce_column);
            if ( ri.ast_node )
                createNode(reduce_line, reduce_column, rule, ri.nt_count, ri.nt_index);
            else if ( ri.nt_count > 0 )
                node_stack_.pop(ri.nt_count);
        }

        void branch(uint action)
        {
            version(ProfileConflicts)
            {
                if ( branch_stack_.length > branch_stack_max )
                    branch_stack_max = branch_stack_.length;
            }
            if ( (action & 128) > 0 )
            {
                version(ProfileConflicts)
                    sr_conflict_counts[stack_.top.index]++;
                version(Tango) debug(parser) Trace.format("{}branch shift conflict\n", indent);
                else debug(parser) writefln("%sbranch shift conflict", indent);
            }
            else
            {
                version(ProfileConflicts)
                    rr_conflict_counts_[stack_.top.index]++;
                version(Tango) debug(parser) Trace.format("{}branch reduce conflict\n", indent_);
                else debug(parser) writefln("%sbranch reduce conflict", indent_);
            }
            version(ProfileConflicts)
                branch_stack_ ~= LRBranch(
                    stack_.dup, node_stack_.dup,
                    input, lookahead_, lookahead_ws_,
                    line, column, symbol, fatal_errors,
                    action, stack_.top.index | (action & 384)
                );
            else
                branch_stack_ ~= LRBranch(
                    stack_.dup, node_stack_.dup,
                    input, lookahead_, lookahead_ws_,
                    line, column, symbol, fatal_errors,
                    action
                );
            fatal_errors = false;
        }

        string prev_input = input;
        parseLoop: while ( true )
        {
            if ( symbol == 0 )
            {
            readSymbol:
                match_ = lookahead_;
                match_ws_ = lookahead_ws_;
                lookahead_ws_ = input;
                static if ( is(WhitespaceGrammar : GLRParser) )
                    ws_parser_.parseWS(input);
                version(Tango)
                    debug(lexer) Trace.format("WS: '{}'\n", lookahead_ws_[0 .. $-input.length]);
                else
                    debug(lexer) writefln("WS: '%s'", lookahead_ws_[0 .. $-input.length]);
                if ( input.length == 0 ) {
                    symbol = EOS;
                    lookahead_ = null;
                }
                else if ( lexer(input, symbol, lookahead_) ) {
                    symbol += FIRST_TOKEN;
                    lookahead_ws_ = lookahead_ws_[0 .. $+lookahead_.length-input.length];
                    countLocation(lookahead_ws_, line, column);
                }
                else
                    throw new ParserException(line, column, filename_, "Invalid token", input[0..$>MAX_INPUT_DUMP?MAX_INPUT_DUMP:$]);
                prev_input = input;
                input = input[lookahead_.length..$];
            }
            auto state = stack_.top.index;
            auto b = action_base_[state];
            uint action = 384;
            b += symbol-EOS;
            if ( b < action_check_.length && action_check_[b] == state )
                action = action_data_[b];
        actionSwitch:
            debug(parser)
            {
                string node_stack_str;
                foreach ( n; node_stack_.array )
                    node_stack_str ~= " "~n.node._ST_node_name~(n.sync?"*":"");
                version(Tango)
                    Trace.format("\n{}state {}\n{}nodes {}\n{}lkahd ({}) {}\n{}input ({}:{}) {}\n",
                        indent_, stack_.top.index,
                        indent_, node_stack_str,
                        indent_, symbol, lookahead_,
                        indent_, line, column,
                        substitute(substitute(input[0..$>MAX_INPUT_DUMP?MAX_INPUT_DUMP:$], "\r", "\\r"), "\n", "\\n")
                    );
                else
                    writefln("\n%sstate %d\n%snodes %s\n%slkahd (%d) %s\n%sinput (%d:%d) %s",
                        indent_, stack_.top.index,
                        indent_, node_stack_str,
                        indent_, symbol, lookahead_,
                        indent_, line, column,
                        replace(replace(input[0..$>MAX_INPUT_DUMP?MAX_INPUT_DUMP:$], "\r", "\\r"), "\n", "\\n")
                    );
            }

            switch ( action & 384 )
            {
                case 128:
                    action &= 127;
                    version(Tango) debug(parser) Trace.format("{}shift {}\n", indent_, action);
                    else debug(parser) writefln("%sshift %d", indent_, action);
                    stack_ ~= LRState(action, line, column);
                    symbol = 0;
                    continue parseLoop;
                case 256:
                    action &= 127;
                    version(Tango) debug(parser) Trace.format("{}reduce {} {}\n", indent_, action, ruleToString(&rule_infos_[action], -1));
                    else debug(parser) writefln("%sreduce %d %s", indent_, action, ruleToString(&rule_infos_[action], -1));
                    auto ri = &rule_infos_[action];
                    uint    reduce_line,
                            reduce_column;
                    if ( ri.symbol_count > 0 ) {
                        reduce_line = stack_.array[$-ri.symbol_count].line;
                        reduce_column = stack_.array[$-ri.symbol_count].column;
                        stack_.pop(ri.symbol_count);
                    }
                    else {
                        reduce_line = stack_.array[$-1].line;
                        reduce_column = stack_.array[$-1].column;
                    }

                    state = stack_.top.index;
                    b = goto_base_[state];
                    b += ri.nt_index;
                    debug(parser)
                    {
                        if ( b < goto_check_.length && goto_check_[b] == state ) {
                            stack_ ~= LRState(goto_data_[b], reduce_line, reduce_column);
                        version(Tango)
                            Trace.format("{}goto {}\n", indent_, stack_.top.index);
                        else
                            writefln("%sgoto %d", indent_, stack_.top.index);
                        }
                        else
                            assert(0, __FILE__~"("~Int.toString(__LINE__)~")");
                    }
                    else
                        stack_ ~= LRState(goto_data_[b], reduce_line, reduce_column);
                    if ( ri.ast_node )
                        createNode(reduce_line, reduce_column, action, ri.nt_count, ri.nt_index);
                    else if ( ri.nt_count > 0 )
                        node_stack_.pop(ri.nt_count);

                    continue parseLoop;
                case 384:
                    action &= 127;
                    if ( fatal_errors || action > 0 )
                    {
                        if ( recover_from_errors_ )
                        {
                            try error(prev_input, line, column, action, symbol);
                            catch ( ParserException e )
                                recovered_errors_ ~= e;
                            version(Tango)
                                debug(nonfatal) Trace.format("recovering from error:\n{}\n", recovered_errors_[$-1]);
                            else
                                debug(nonfatal) writefln("recovering from error:\n%s", recovered_errors_[$-1]);
                            while ( !stack_.empty && !isErrorSynced(stack_.top.index) )
                                stack_.pop;
                            while ( !node_stack_.empty && !node_stack_.top.sync )
                                node_stack_.pop;
                            symbol = 0;
                            continue parseLoop;
                        }
                        else
                        {
                            input = prev_input;
                            foreach ( bs; branch_stack_.array ) {
                                bs.stack.free;
                                bs.node_stack.free;
                            }
                            branch_stack_.clear;
                            error(input, line, column, action, symbol);
                        }
                    }
                    else
                    {
                        debug(nonfatal) {
                            input = prev_input;
                            error(input, line, column, action, symbol, false);
                        }
                    }
                    if ( branch_stack_.length == 0 ) {
                        input = prev_input;
                        return false;
                    }
                    auto prev = branch_stack_.popPtr;
                    stack_.free;
                    stack_          = prev.stack;
                    node_stack_.free;
                    node_stack_     = prev.node_stack;
                    input           = prev.input;
                    prev_input      = input;
                    lookahead_      = prev.lookahead;
                    lookahead_ws_   = prev.lookahead_ws;
                    line            = prev.line;
                    column          = prev.column;
                    symbol          = prev.symbol;
                    fatal_errors    = prev.fatal_errors;
                    action          = prev.action;

                    version(ProfileConflicts)
                    {
                        if ( (prev.last_conflict & 128) > 0 )
                            shift_failed_counts[prev.last_conflict & 127]++;
                        else
                            reduce_failed_counts[prev.last_conflict & 127]++;
                    }
                    goto actionSwitch;
                default:
                    break;
            }

            switch ( action )
            {
                case 0:
                    branch(282);
                    version(Tango)
                        debug(parser) Trace.format("{}shift 5\n", indent);
                    else
                        debug(parser) writefln("%sshift 5", indent);
                    stack_ ~= LRState(5, line, column);
                    symbol = 0;
                    break;
                case 1:
                    branch(288);
                    reduce(28);
                    break;
                case 2:
                    branch(304);
                    version(Tango)
                        debug(parser) Trace.format("{}shift 58\n", indent);
                    else
                        debug(parser) writefln("%sshift 58", indent);
                    stack_ ~= LRState(58, line, column);
                    symbol = 0;
                    break;
                case 3:
                    version(Tango)
                        debug(parser) Trace.format("{}accept\n", indent);
                    else
                        debug(parser) writefln("%saccept", indent);
                    syntax_root_ = node_stack_.top.node;

                    foreach ( bs; branch_stack_.array ) {
                        bs.stack.free;
                        bs.node_stack.free;
                    }
                    branch_stack_.clear;
                    input = prev_input;
                    return true;
                default:
                    assert(0, __FILE__~"("~Int.toString(__LINE__)~")");
            }
        }
        assert(0, __FILE__~"("~Int.toString(__LINE__)~")");
    }
}

class WhitespaceGrammar : public GLRParser
{
    const ubyte[]  action_base_ =
    [
        0,5,15,25,34,43,52,61,70,79,88,98,107,116,126,131,136
    ];
    const ubyte[]  action_check_ =
    [
        17,0,0,0,0,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,4,4,4,4,17,4,4,4,4,5,
        5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,8,9,9,9,9,9,9,9,9,9,10,
        10,10,10,10,10,10,10,10,11,11,11,11,11,11,11,11,11,11,12,12,12,12,12,12,12,12,12,13,13,13,
        13,13,13,13,13,13,14,14,14,14,14,15,15,15,15,15,16,16,16,16,16
    ];
    const ubyte[]  action_data_ =
    [
        48,17,18,19,20,34,34,34,34,34,34,34,34,34,34,35,35,35,35,35,35,35,35,35,35,36,36,36,36,36,
        36,36,36,36,36,17,18,19,20,48,21,22,23,24,41,41,41,41,41,41,41,41,41,42,42,42,42,42,42,42,
        42,42,43,43,43,43,43,43,43,43,43,44,44,44,44,44,44,44,44,44,40,40,40,40,40,40,40,40,40,17,
        18,19,20,27,21,22,23,24,37,37,37,37,37,37,37,37,37,37,38,38,38,38,38,38,38,38,38,39,39,39,
        39,39,39,39,39,39,0,17,18,19,20,32,32,32,32,32,33,33,33,33,33
    ];
    const ubyte[]  goto_base_ =
    [
        0,0,0,0,1,0,0,0,0,0,4,0,0,0,5,0,0
    ];
    const ubyte[]  goto_check_ =
    [
        0,0,4,4,4,10,14,10
    ];
    const ubyte[]  goto_data_ =
    [
        14,16,9,10,13,9,15,12
    ];

    debug(parser) string indent_;

    this(GLRParser ws=null, uint tab_width=4)
    {
        super(ws, tab_width);
        lexer = &wsLexer;
        first_nt_ = 13;
        nt_names_ =
        [
            "Whitespace","WhitespaceFlat","WhitespaceNesteds","WhitespaceNested","!LRstart"
        ];
        lexeme_names_ =
        [
            "EOS","[\\n\\r\\t ]+","//[^\\n]*","/\\*([^\\*]|\\*>/)*\\*/","/\\+","\\+/",
            "[^#/\\+\\*\\n\\r\\t ]+","\\+","\\*","/"
        ];
        entry_infos_ =
        [
            cast(EntryInfo[])[],[EntryInfo(2,1)],[EntryInfo(3,1)],[EntryInfo(4,1)],[EntryInfo(5,1)],[
            EntryInfo(9,1)],[EntryInfo(10,1)],[EntryInfo(11,1)],[EntryInfo(12,1)],[EntryInfo(8,1)],[
            EntryInfo(5,2),EntryInfo(6,1)],[EntryInfo(5,3)],[EntryInfo(6,2)],[EntryInfo(7,1)],[EntryInfo(13,1)
            ,EntryInfo(0,1)],[EntryInfo(0,2)],[EntryInfo(1,1)]
        ];
        rule_infos_ =
        [
            RuleInfo(true,2,2,0,[ 4096, 4097 ]),RuleInfo(true,1,1,0,[ 4097 ]),
            RuleInfo(true,1,0,1,[ 4 ]),RuleInfo(true,1,0,1,[ 5 ]),RuleInfo(true,1,0,1,[ 6 ]),
            RuleInfo(true,3,1,1,[ 7, 4098, 8 ]),RuleInfo(true,2,2,2,[ 4098, 4099 ]),
            RuleInfo(true,1,1,2,[ 4099 ]),RuleInfo(true,1,1,3,[ 4097 ]),RuleInfo(true,1,0,3,[ 9 ]),
            RuleInfo(true,1,0,3,[ 10 ]),RuleInfo(true,1,0,3,[ 11 ]),RuleInfo(true,1,0,3,[ 12 ]),
            RuleInfo(true,1,1,4,[ 4096 ])
        ];
        syntax_node_cinfos_ =
        [
            SyntaxTree.classinfo,SyntaxTree.classinfo,SyntaxTree.classinfo,SyntaxTree.classinfo,
            SyntaxTree.classinfo
        ];
        error_message_lists_ = [
            cast(string[])null
        ];
    }

    uint[] lookaheadForNT(uint nt_index, uint state)
    {
        uint[] tokens;
        auto b = action_base_[state];
        auto m = APDmin(action_check_.length, cast(size_t)b+first_nt_);
        foreach ( i, check; action_check_[b .. m] )
        {
            if ( check == state && (action_data_[b+i] & 48) == 32 )
                tokens ~= i+EOS;
        }
        return tokens;
    }

    override bool isErrorSynced(uint state)
    {
        switch ( state )
        {
            case 0:
                return true;
            default:
                break;
        }
        return false;
    }

    override bool parseWS(ref string input)
    {
        stack_.clear;
        stack_ ~= LRState(0, 1, 1);

        debug(parser) indent_ ~= " ";


        bool    fatal_errors = true;
        uint    line = 1,
                column = 1,
                symbol;

        void reduce(uint rule)
        {
            version(Tango)
                debug(parser) Trace.format("{}reduce {} {}\n", indent_, rule, ruleToString(&rule_infos_[rule], -1));
            else
                debug(parser) writefln("%sreduce %d %s", indent_, rule, ruleToString(&rule_infos_[rule], -1));
            auto ri = &rule_infos_[rule];
            uint    reduce_line,
                    reduce_column;
            if ( ri.symbol_count > 0 ) {
                reduce_line = stack_.array[$-ri.symbol_count].line;
                reduce_column = stack_.array[$-ri.symbol_count].column;
                stack_.pop(ri.symbol_count);
            }
            else {
                reduce_line = stack_.top.line;
                reduce_column = stack_.top.column;
            }

            auto b = goto_base_[stack_.top.index];
            b += ri.nt_index;
            debug(parser)
            {
                if ( b < goto_check_.length && goto_check_[b] == stack_.top.index ) {
                    stack_ ~= LRState(goto_data_[b], reduce_line, reduce_column);
                }
                else
                    assert(0, __FILE__~"("~Int.toString(__LINE__)~")");
            }
            else
                stack_ ~= LRState(goto_data_[b], reduce_line, reduce_column);
        }

        void branch(uint action)
        {
            version(ProfileConflicts)
            {
                if ( branch_stack_.length > branch_stack_max )
                    branch_stack_max = branch_stack_.length;
            }
            if ( (action & 16) > 0 )
            {
                version(ProfileConflicts)
                    sr_conflict_counts[stack_.top.index]++;
            }
            else
            {
                version(ProfileConflicts)
                    rr_conflict_counts_[stack_.top.index]++;
            }
            version(ProfileConflicts)
                branch_stack_ ~= LRBranch(
                    stack_.dup, node_stack_.dup,
                    input, lookahead_, lookahead_ws_,
                    line, column, symbol, fatal_errors,
                    action, stack_.top.index | (action & 48)
                );
            else
                branch_stack_ ~= LRBranch(
                    stack_.dup, node_stack_.dup,
                    input, lookahead_, lookahead_ws_,
                    line, column, symbol, fatal_errors,
                    action
                );
            fatal_errors = false;
        }

        string prev_input = input;
        parseLoop: while ( true )
        {
            if ( symbol == 0 )
            {
            readSymbol:
                match_ = lookahead_;
                match_ws_ = lookahead_ws_;
                if ( input.length == 0 ) {
                    symbol = EOS;
                    lookahead_ = null;
                }
                else if ( lexer(input, symbol, lookahead_) ) {
                    symbol += FIRST_TOKEN;
                }
                else
                    return false;
                prev_input = input;
                input = input[lookahead_.length..$];
            }
            auto state = stack_.top.index;
            auto b = action_base_[state];
            uint action = 48;
            b += symbol-EOS;
            if ( b < action_check_.length && action_check_[b] == state )
                action = action_data_[b];
        actionSwitch:

            switch ( action & 48 )
            {
                case 16:
                    action &= 15;
                    stack_ ~= LRState(action, line, column);
                    symbol = 0;
                    continue parseLoop;
                case 32:
                    action &= 15;
                    auto ri = &rule_infos_[action];
                    uint    reduce_line,
                            reduce_column;
                    if ( ri.symbol_count > 0 ) {
                        reduce_line = stack_.array[$-ri.symbol_count].line;
                        reduce_column = stack_.array[$-ri.symbol_count].column;
                        stack_.pop(ri.symbol_count);
                    }
                    else {
                        reduce_line = stack_.array[$-1].line;
                        reduce_column = stack_.array[$-1].column;
                    }

                    state = stack_.top.index;
                    b = goto_base_[state];
                    b += ri.nt_index;
                    debug(parser)
                    {
                        if ( b < goto_check_.length && goto_check_[b] == state ) {
                            stack_ ~= LRState(goto_data_[b], reduce_line, reduce_column);
                        }
                        else
                            assert(0, __FILE__~"("~Int.toString(__LINE__)~")");
                    }
                    else
                        stack_ ~= LRState(goto_data_[b], reduce_line, reduce_column);

                    continue parseLoop;
                case 48:
                    action &= 15;
                    input = prev_input;
                    if ( branch_stack_.length == 0 ) {
                        input = prev_input;
                        return false;
                    }
                    auto prev = branch_stack_.popPtr;
                    stack_.free;
                    stack_          = prev.stack;
                    node_stack_.free;
                    node_stack_     = prev.node_stack;
                    input           = prev.input;
                    prev_input      = input;
                    lookahead_      = prev.lookahead;
                    lookahead_ws_   = prev.lookahead_ws;
                    line            = prev.line;
                    column          = prev.column;
                    symbol          = prev.symbol;
                    fatal_errors    = prev.fatal_errors;
                    action          = prev.action;

                    version(ProfileConflicts)
                    {
                        if ( (prev.last_conflict & 16) > 0 )
                            shift_failed_counts[prev.last_conflict & 15]++;
                        else
                            reduce_failed_counts[prev.last_conflict & 15]++;
                    }
                    goto actionSwitch;
                default:
                    break;
            }

            switch ( action )
            {
                case 0:
                    input = prev_input;
                    return true;
                default:
                    assert(0, __FILE__~"("~Int.toString(__LINE__)~")");
            }
        }
        assert(0, __FILE__~"("~Int.toString(__LINE__)~")");
    }
}


// generated code end
