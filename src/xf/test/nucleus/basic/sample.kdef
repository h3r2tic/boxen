CheckerGen = kernel Image(
	in size <type float2>
) {
	float2 meh = step(float2(0.5, 0.5), frac(uv * size)) * 2 - 1;
	sample = (meh.x * meh.y) * 0.5 + 0.5;
};


BlurImage = kernel(
	in uv <type float2>,
	in offset <type float2>,
	in img <type Image>,
	out sample <type float4>
) {
    // 1D Gaussian 7 taps coefficients
    const float coeff[7] = {0.006f, 0.061f, 0.242f, 0.382f, 0.242f, 0.061f, 0.006f};     

	float4 res = 0;
	res += img.sample(uv - offset) * coeff[0];
	res += img.sample(uv - offset * (2.0 / 3)) * coeff[1];
	res += img.sample(uv - offset * (1.0 / 3)) * coeff[2];
	res += img.sample(uv) * coeff[3];
	res += img.sample(uv + offset * (1.0 / 3)) * coeff[4];
	res += img.sample(uv + offset * (2.0 / 3)) * coeff[5];
	res += img.sample(uv + offset) * coeff[6];
	sample = res;
};


// Insanely hacky, but what the hell :P
FixedBlurHack = kernel(
	in uv <type float2>,
	in img <type Image>,
	out sample <type float4>
) {
	uv.x += 0.5f / 1040;
	uv.y += 0.5f / 650;
	//float2 offset = float2(6.0f / 1040, 0);
	float2 offset = float2(6.0f / 1040, 0);

    // 1D Gaussian 7 taps coefficients
    const float coeff[7] = {0.006f, 0.061f, 0.242f, 0.382f, 0.242f, 0.061f, 0.006f};     

	float4 res = 0;
	res += img.sample(uv - offset) * coeff[0];
	res += img.sample(uv - offset * (2.0 / 3)) * coeff[1];
	res += img.sample(uv - offset * (1.0 / 3)) * coeff[2];
	res += img.sample(uv) * coeff[3];
	res += img.sample(uv + offset * (1.0 / 3)) * coeff[4];
	res += img.sample(uv + offset * (2.0 / 3)) * coeff[5];
	res += img.sample(uv + offset) * coeff[6];
	sample = res;
};

// Insanely hacky, but what the hell :P
FixedBlurHack2 = kernel(
	in uv <type float2>,
	in img <type Image>,
	out sample <type float4>
) {
	uv.x -= 0.5f / 1040;
	uv.y -= 0.5f / 650;
	float2 offset = float2(0, 6.0f / 650);

    // 1D Gaussian 7 taps coefficients
    const float coeff[7] = {0.006f, 0.061f, 0.242f, 0.382f, 0.242f, 0.061f, 0.006f};     

	float4 res = 0;
	res += img.sample(uv - offset) * coeff[0];
	res += img.sample(uv - offset * (2.0 / 3)) * coeff[1];
	res += img.sample(uv - offset * (1.0 / 3)) * coeff[2];
	res += img.sample(uv) * coeff[3];
	res += img.sample(uv + offset * (1.0 / 3)) * coeff[4];
	res += img.sample(uv + offset * (2.0 / 3)) * coeff[5];
	res += img.sample(uv + offset) * coeff[6];
	sample = res;
};


DefaultMeshStructure = graph Structure {
	node_0 = node {
		type = input;
		params = (
			position <type float3 + basis model + use position>,
			normal <type float3 + basis model + use normal>,
			texCoord <type float2 + use uv>
		);
	};
	node_1 = node {
		type = kernel;
		kernel = Rasterize;
	};
	node_2 = node {
		type = output;
	};

	connect node_0 node_1;
	connect node_0 node_2;
};


TestSurface1 = surface CookTorrance {
	roughness = 0.2;
};

TestSurface2 = surface BlinnPhong {
	//roughness = 0.3;
	specularPower = 60;
};

TestSurface3 = surface AshikhminShirley {
	roughness = 0.7;
};

TestSurface4 = surface CookTorrance {
	roughness = 0.95;
};


TestMaterial = material TestPigment {
	albedoTint = 1 1 1 1;
	albedoTex = sampler {
		texture = "../../media/img/testgrid.png";
		minFilter = mipmapLinear;
		magFilter = linear;
	};
};


TestLight = graph Light {
	n0 = node {
		type = input;
	};
	n1 = node {
		type = data;
		params = (
			lightPos <type float3 + use lightPos> = 0 1 -2,
			lumIntens <type float4 + use lumIntens> = 1 1 1 1
		);
	};
	n2 = node {
		type = kernel;
		kernel = kernel Light(
			lightPos <type float3 + use lightPos>,
			lumIntens <type float4 + use lumIntens>
		) {
			toLight = lightPos - position;
			intensity = lumIntens / (float4(1) + dot(toLight, toLight).xxxx);
			toLight = normalize(toLight);
		};
	};
	n3 = node {
		type = output;
	};

	connect n0 n2;
	connect n1 n2;
	connect n2 n3;
};


TestPigment = graph Pigment {
	n0 = node {
		type = input;
	};
	n1 = node {
		type = data;
		params = (
			albedoTint <type float4 + use color> = 1 1 1 1,
			albedoTex <type sampler2D + use color>,
			blurOffset <type float2> = 0.002 0.002,
			albedoScale <type float4> = 4 4 4 4
		);
	};
	ns = node {
		type = kernel;
		kernel = Tex2D;		
	};
	nb = node {
		type = kernel;
		kernel = BlurImage;
	};
	nsub = node {
		type = kernel;
		kernel = Sub;
	};
	nmul = node {
		type = kernel;
		kernel = Mul;
	};
	n2 = node {
		type = kernel;
		kernel = kernel Pigment(
			albedoTint <type float4 + use color>,
			someImg <type Image>
		) {
			float4 albedo = diffuse * albedoTint * abs(someImg.sample(texCoord));

			radiance = albedo + specular;
			// NOTE: 1 - saturate() added to counter the post-proc test's negative
			//radiance = 1 - saturate(albedo + specular);
/+			radiance = someImg.sample(texCoord);
			radiance = abs(radiance);+/
		};
	};
	n3 = node {
		type = output;
	};

	// ----

	connect n1 ns;

	connect n1.blurOffset nb.offset;
	connect ns.sample nb.img;		// albedo tex -> blur

	connect nb.sample nsub.a;
	connect ns.sample nsub.b;

	connect nsub.c nmul.a;			// blurred - orig
	connect n1.albedoScale nmul.b;

	connect nmul.c n2.someImg;		

	// ----

	noauto nb.uv;
	noauto ns.uv;

	// ----

	connect n0 n2;
	connect n1.albedoTint n2.albedoTint;
	connect n2 n3;
};


TestPigment2 = graph Pigment {
	n0 = node {
		type = input;
	};
	n1 = node {
		type = data;
		params = (
			albedoTint <type float4 + use color> = 1 1 1 1,
			albedoTex <type sampler2D + use color>,
			blurOffset <type float2> = 0.002 0.002,
			checkerSize <type float2> = 30 30
		);
	};
	ng = node {
		type = kernel;
		kernel = CheckerGen;
	};
	ns = node {
		type = kernel;
		kernel = Tex2D;		
	};
	nb = node {
		type = kernel;
		kernel = BlurImage;
	};
	na = node {
		type = kernel;
		kernel = Add;
	};
	n2 = node {
		type = kernel;
		kernel = kernel Pigment(
			albedoTint <type float4 + use color>,
			someImg <type Image>
		) {
			float4 albedo = diffuse * albedoTint * someImg.sample(texCoord);
			radiance = albedo + specular;
		};
	};
	n3 = node {
		type = output;
	};

	// ----

	connect n1.checkerSize ng.size;
	connect n1.blurOffset nb.offset;

	connect n1 ns;

	connect ng.sample na.a;			// procedural tex -> sum
	connect ns.sample na.b;			// albedo tex -> sum

	//connect ng.sample nb.img;		// procedural tex -> blur
	//connect ns.sample nb.img;		// albedo tex -> blur
	connect na.c nb.img;			// sum -> blur

	connect nb.sample n2.someImg;	// blur -> out

	//connect nb.sample n2.someImg;	// albedo tex -> out
	//connect ng.sample n2.someImg;	// procedural tex -> out

	// ----

	noauto nb.uv;
	noauto ng.uv;
	noauto ns.uv;

	// ----

	connect n0 n2;
	connect n1.albedoTint n2.albedoTint;
	connect n2 n3;
};


SpecularOnly = kernel Pigment {
	radiance = specular;
};


TestPostX = graph {
	n0 = node {
		type = input;
		params = (
			input <type Image>
		);
	};

	ns = node {
		type = kernel;
		kernel = SampleImage;
	};

	n1 = node {
		type = kernel;
		kernel = FixedBlurHack;
	};

	nb = node {
		type = kernel;
		kernel = Blit;
	};

	n11 = node {
		type = kernel;
		kernel = FixedBlurHack2;
	};

	n2 = node {
		type = output;
		params = (
			output <type Image>
		);
	};


	connect n0.input ns.image;
	connect ns.sample n1.img;
	connect n1.sample nb.input;
	connect nb.output n11.img;
	connect n11.sample n2.output;
	noauto n1.uv;
	noauto n11.uv;
	noauto ns.uv;
};


TestPost = graph {
	n0 = node {
		type = input;
		params = (
			input <type Image>
		);
	};

	ns = node {
		type = kernel;
		kernel = SampleImage;
	};

	ns2 = node {
		type = kernel;
		kernel = SampleImage;
	};

	n1 = node {
		type = kernel;
		kernel = TestPostX;
	};

	nb = node {
		type = kernel;
		kernel = Blit;
	};

	n2 = node {
		type = kernel;
		kernel = TestPostX;
	};

	n3 = node {
		type = output;
		params = (
			output <type Image>
		);
	};

	n4 = node {
		type = kernel;
		kernel = AddGlare;
	};

	connect n0.input n1.input;
	connect n1.output nb.input;
	connect nb.output n2.input;

	connect n0.input ns.image;
	connect ns.sample n4.baseColor;
	connect n2.output ns2.image;
	connect ns2.sample n4.blurredColor;
	connect n4.output n3.output;

	noauto ns.uv;
	noauto ns2.uv;
	
	//connect n2.output n3.output;
};


AddGlare = kernel(
	in baseColor <type float4>,
	in blurredColor <type float4>,
	out output <type float4>
) {
	output = saturate(saturate(blurredColor)*0.3-0.05);//saturate(saturate(blurredColor*0.3)-0.3) + baseColor;
	output += baseColor;
};



TestPost3 = graph {
	n0 = node {
		type = input;
		params = (
			input <type Image>
		);
	};

	ns = node {
		type = kernel;
		kernel = SampleImage;
	};

	nn = node {
		type = kernel;
		kernel = OneMinus;
	};

	n1 = node {
		type = kernel;
		kernel = FixedBlurHack;
	};

	n2 = node {
		type = output;
		params = (
			output <type Image>
		);
	};


	/+connect n0.input n1.img;
	connect n1.sample n2.output;
	noauto n1.uv;+/

	connect n0.input ns.image;
	connect ns.sample nn.a;
	connect nn.b n1.img;
	connect n1.sample n2.output;
	noauto n1.uv;
	noauto ns.uv;
};


TestPost4 = graph {
	n0 = node {
		type = input;
		params = (
			input <type Image>
		);
	};

	ns = node {
		type = kernel;
		kernel = SampleImage;
	};

	nn = node {
		type = kernel;
		kernel = OneMinus;
	};

	n1 = node {
		type = kernel;
		kernel = FixedBlurHack;
	};

	n11 = node {
		type = kernel;
		kernel = FixedBlurHack2;
	};

	n2 = node {
		type = output;
		params = (
			output <type Image>
		);
	};


	/+connect n0.input n1.img;
	connect n1.sample n2.output;
	noauto n1.uv;+/

	connect n0.input ns.image;
	connect ns.sample nn.a;
	connect nn.b n1.img;
	connect n1.sample n11.img;
	connect n11.sample n2.output;
	noauto n1.uv;
	noauto n11.uv;
	noauto ns.uv;
};


TestPostNop = graph {
	n0 = node {
		type = input;
		params = (
			input <type Image>
		);
	};

	n1 = node {
		type = kernel;
		kernel = SampleImage;
	};

	n2 = node {
		type = output;
		params = (
			output <type Image>
		);
	};


	connect n0.input n1.image;
	connect n1.sample n2.output;
	noauto n1.uv;
};
