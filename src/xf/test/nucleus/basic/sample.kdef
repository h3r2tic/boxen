//TestSurface1 = surface Lambert {};

/+TestSurface1 = surface ABg {
	BRDF_A = 0.06;
	BRDF_B = 0.001;
	BRDF_g = 1.3;
};+/

ParticleSurface = surface Uniform {};

/+TestSurface1 = surface HenyeyGreenstein {
	roughness = 0.5;
};+/


/*
TestSurface1 = surface CookTorrance {
	fresnelR0 = 0.18;
	roughness = 0.9;
};
/*/
TestSurface1 = surface ABC_approx2 {
	BRDF_A = 1;
	BRDF_B = 40.0;
	BRDF_C = 0.9;
};
//*/


TestSurface4 = surface HalfLambert {
};

TestSurface2 = surface ABg_h {
	BRDF_A = 0.0025;
	BRDF_B = 0.0001;
	BRDF_g = 1.8;
};

TestSurface3 = surface ABg_h {
	BRDF_A = 0.06;
	BRDF_B = 0.001;
	BRDF_g = 1.3;
};

/+TestSurface3 = surface ABC {
	BRDF_A = 1;
	BRDF_B = 33333;
	BRDF_C = 0.37;
};+/

/+TestSurface1 = surface ABg_h {
	BRDF_A = 0.0025;
	BRDF_B = 0.0001;
	BRDF_g = 1.8;
};

TestSurface4 = surface ABg_h {
	BRDF_A = 0.06;
	BRDF_B = 0.001;
	BRDF_g = 1.3;
};+/


TestPost = graph PostProcess {
	input = node {
		type = input;
	};

	data = node {
		type = data;
		params = (
			randSampler <type sampler2D + use color> = sampler {
				texture = "img/random.bmp";
				minFilter = nearest;
				magFilter = nearest;
			},
			distortSampler <type sampler2D + use color> = sampler {
				texture = "img/noise.jpg";
				minFilter = linear;
				magFilter = linear;
			}
		);
	};

	clampInput = node {
		type = kernel;
		kernel = kernel(
			in input <type float4 + use color>,
			out output <type float4 + use color>
		) {
			output = min(input, float4(16));
		};
	};

	blur1 = node {
		type = kernel;
		kernel = BlurAndDownsample;
	};

	blur2 = node {
		type = kernel;
		kernel = BlurAndDownsample;
	};

	blur3 = node {
		type = kernel;
		kernel = BlurAndDownsample;
	};

	blur4 = node {
		type = kernel;
		kernel = BlurAndDownsample;
	};

	blur5 = node {
		type = kernel;
		kernel = BlurAndDownsample;
	};

	blur6 = node {
		type = kernel;
		kernel = BlurAndDownsample;
	};

	blur7 = node {
		type = kernel;
		kernel = Blur4;
	};

	blur8 = node {
		type = kernel;
		kernel = Blur4;
	};

	blur9 = node {
		type = kernel;
		kernel = Blur4;
	};

	blur10 = node {
		type = kernel;
		kernel = Blur4;
	};

	sampleOrig = node {
		type = kernel;
		kernel = SampleImage;
	};

	sampleBlurred = node {
		type = kernel;
		kernel = SampleImage;
	};

	sampleBlurred2 = node {
		type = kernel;
		kernel = SampleImage;
	};

	sampleBlurred3 = node {
		type = kernel;
		kernel = SampleImage;
	};

	sampleBlurred4 = node {
		type = kernel;
		kernel = SampleImage;
	};

	output = node {
		type = output;
	};

	glare = node {
		type = kernel;
		kernel = AddGlare;
	};

	noise = node {
		type = kernel;
		kernel = AddNoise;
	};

	distort = node {
		type = kernel;
		kernel = kernel(
			in baseColor <type Image>,
			in distortSampler <type sampler2D + use color>,
			in uv <type float2 + use uv>,
			out output <type float4 + use color>
		) {
			float2 off = cos(tex2D(distortSampler, uv * 3 + time.minute).xy * 27.123 + radians(time.second * 360)) * 0.005;
			float2 meh = smoothstep(1, 0.9, saturate(2 * abs(uv - float2(0.5))));
			output = baseColor.sample(saturate(uv + 0*off * meh));
		};
	};

//	connect input blur1;
	connect sampleOrig.sample clampInput.input;
	connect clampInput.output distort.baseColor;
	connect distort.output blur1.input;
	connect input.size blur1.inputSize;
	connect data.randSampler noise.noiseSampler;
	connect data.distortSampler distort.distortSampler;

	connect blur1 blur2;
	connect blur2 blur3;
	connect blur3 blur4;
	connect blur4 blur5;
	connect blur5 blur6;
	connect blur6 blur7;
	connect blur7 blur8;
	connect blur8 blur9;
	connect blur9 blur10;

	connect blur1 sampleBlurred;
	connect blur2 sampleBlurred2;
	connect blur3 sampleBlurred3;
	connect blur9 sampleBlurred4;
	connect input sampleOrig;

	connect distort.output glare.baseColor;
	connect sampleBlurred.sample glare.blurredColor;
	connect sampleBlurred2.sample glare.blurredColor2;
	connect sampleBlurred3.sample glare.blurredColor3;
	connect sampleBlurred4.sample glare.blurredColor4;

	connect glare.output noise.baseColor;
	connect noise.output output.output;

	noauto sampleOrig.uv;
	noauto sampleBlurred.uv;
	noauto sampleBlurred2.uv;
	noauto sampleBlurred3.uv;
	noauto sampleBlurred4.uv;
	noauto noise.uv;
	noauto distort.uv;
};

