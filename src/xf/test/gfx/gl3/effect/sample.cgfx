interface ILight {
	float4 illuminate(float3 pos, float3 norm);
};


struct AmbientLight : ILight {
	float4 color;

	float4 illuminate(float3 pos, float3 norm) {
		return color;
	}
};


struct PointLight : ILight {
	float3 position;
	float4 color;

	float4 illuminate(float3 point, float3 norm) {
		float3 toLight = position - point;
		float4 falloff = saturate(dot(normalize(toLight), norm).xxxx);
		return color * falloff / dot(toLight, toLight).xxxx;
	}
};


// not supposed to do anything useful, just a mock


struct vertInput {
	float3 position : POSITION;
	float3 normal : TEXCOORD0;
};

struct fragInput {
	float3 position : TEXCOORD0;
	float3 normal : TEXCOORD1;
};


float4x4 modelToWorld;
float4x4 worldToScreen;


uniform ILight[] lights;


void VertexProgram(
	in vertInput input,
	out float4 outPos : POSITION,
	out fragInput output
) {
	outPos = mul(modelToWorld, float4(input.position, 1.0f));
	outPos = mul(worldToScreen, outPos);
	
	output.position = input.position;
	output.normal = input.normal;
}


void FragmentProgram(
	in fragInput input,
	out float4 output : COLOR
) {
	output = float4(0, 0, 0, 0);
	float3 normal = normalize(input.normal);
	for (int i = 0; i < lights.length; ++i) {
		output += lights[i].illuminate(input.position, normal);
	}
}
