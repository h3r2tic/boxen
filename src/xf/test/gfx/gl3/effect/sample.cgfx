interface ILight {
	float4 illuminate(float3 pos, float3 norm);
};


struct AmbientLight : ILight {
	float4 color;

	float4 illuminate(float3 pos, float3 norm) {
		return color;
	}
};


struct PointLight : ILight {
	float3 position;
	float4 color;

	float4 illuminate(float3 point, float3 norm) {
		float3 toLight = position - point;
		float4 falloff = saturate(dot(normalize(toLight), norm).xxxx);
		return color * falloff / dot(toLight, toLight).xxxx;
	}
};


// not supposed to do anything useful, just a mock


struct vertInput {
	float3 position : POSITION;
	float3 normal : TEXCOORD0;
	float2 texCoord : TEXCOORD1;
};

struct fragInput {
	float3	position : TEXCOORD0;
	float3	normal : TEXCOORD1;
	float2	texCoord : TEXCOORD2;
};


float3x4 modelToWorld;
float4x4 worldToView <
	string scope = "effect";
>;
float4x4 viewToClip <
	string scope = "effect";
>;


struct EnvData {
	float4	ambientColor;
	float	lightScale;
};
EnvData envData : BUFFER[0];


uniform ILight[] lights;

void VertexProgram(
	in vertInput input,
	int instance : INSTANCEID,
	out float4 outPos : POSITION,
	out fragInput output
) {
	float3 worldPos = mul(modelToWorld, float4(input.position, 1));
	worldPos.x += instance * 3.5;
	outPos = mul(viewToClip, mul(worldToView, float4(worldPos, 1.0)));
	
	output.position = worldPos;
	output.normal = input.normal;
	output.texCoord = input.texCoord;
}


void FragmentProgram(
	in fragInput input,
	uniform sampler2D diffuseTex,
	out float4 output : COLOR
) {
	output = envData.ambientColor;
	float3 normal = normalize(input.normal);
	for (int i = 0; i < lights.length; ++i) {
		output += lights[i].illuminate(input.position, normal);
	}
	output *= envData.lightScale;
	
	output *= /*float4(1,1,1,1) + */tex2D(diffuseTex, input.texCoord);
}
