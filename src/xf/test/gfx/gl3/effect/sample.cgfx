interface ILight {
	void sample(
		float3 point,
		float3 normal,
		out float3 toLight,
		out float4 illuminance
	);
};


struct AmbientLight : ILight {
	float4 color;

	void sample(
		float3 point,
		float3 normal,
		out float3 toLight,
		out float4 illuminance
	) {
		toLight = normal;
		illuminance = color;
	}
};


struct PointLight : ILight {
	float3 position;
	float4 color;

	void sample(
		float3 point,
		float3 normal,
		out float3 toLight,
		out float4 illuminance
	) {
		toLight = position - point;
		float distAtten = 1.0f / dot(toLight, toLight).x;
		toLight = normalize(toLight);
		float4 falloff = saturate(dot(toLight, normal).xxxx);
		illuminance = color * falloff * distAtten;
	}
};


// not supposed to do anything useful, just a mock


struct vertInput {
	float3 position : POSITION;
	float3 normal : TEXCOORD0;
	float3 tangent : TEXCOORD1;
	float3 bitangent : TEXCOORD2;
	float2 texCoord : TEXCOORD3;
};

struct fragInput {
	float3 position : TEXCOORD0;
	float3 normal : TEXCOORD1;
	float3 tangent : TEXCOORD2;
	float3 bitangent : TEXCOORD3;
	float2 texCoord : TEXCOORD4;
};


float3x4 modelToWorld;
float4x4 worldToView <
	string scope = "effect";
>;
float4x4 viewToClip <
	string scope = "effect";
>;


struct EnvData {
	float4	ambientColor;
	float3	eyePos;
	float	lightScale;
};
EnvData envData : BUFFER[0];

#include "strauss.cg"
#include "phong.cg"

uniform ILight[] lights;


void VertexProgram(
	in vertInput input,
	int instance : INSTANCEID,
	out float4 outPos : POSITION,
	out fragInput output
) {
	float3 worldPos = mul(modelToWorld, float4(input.position, 1));
	worldPos.x += instance * 3.5;
	outPos = mul(viewToClip, mul(worldToView, float4(worldPos, 1.0)));
	
	output.position = worldPos;
	output.normal = input.normal;
	output.tangent = input.tangent;
	output.bitangent = input.bitangent;
	output.texCoord = input.texCoord;
}


void FragmentProgram(
	in fragInput input,
	uniform sampler2D diffuseTex,
	uniform sampler2D specularTex,
	uniform float smoothness,
	uniform float4 diffuseTint,
	uniform float4 specularTint,
	out float4 output : COLOR
) {
	const float metalness = 0.9f;

	float4 diffuseSum = envData.ambientColor;
	float4 specularSum = float4(0, 0, 0, 0);
	
	float3 normal = normalize(input.normal);
	for (int i = 0; i < lights.length; ++i) {
		float3 toLight;
		float4 illum, diffuse, specular;
		
		lights[i].sample(input.position, normal, toLight, illum);
		StraussBRDF(
			illum,
			normal,
			input.position,
			toLight,
			smoothness,
			metalness,
			diffuse,
			specular
		);
		
		/*PhongBRDF(
			illum,
			normal,
			input.position,
			toLight,
			smoothness * 90.0f,
			diffuse,
			specular
		);*/
		
		diffuseSum += diffuse;
		specularSum += specular;
	}
	
	output =
		tex2D(diffuseTex, input.texCoord) * diffuseSum * diffuseTint
	+	tex2D(specularTex, input.texCoord) * specularSum * specularTint;
	
	output *= envData.lightScale;
}
