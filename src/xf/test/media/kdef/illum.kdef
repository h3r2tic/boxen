HenyeyGreenstein = graph Reflectance {
	n0 = node {
		type = input;
	};
	n1 = node {
		type = data;
		params = (
			roughness <type float>
		);
	};
	n2 = node {
		type = kernel;
		kernel = kernel Reflectance(
			in roughness <type float>
		) {
			float3 R = reflect(-toLight,normal);
			float3 vi = toLight;
			float3 vo = toEye;
			float3 vs = R;
			float3 B = vo - dot(vo, normal).xxx * normal;
			float3 B0 = vs - dot(vs, normal).xxx * normal;

			float cosTh;
			//cosTh = max(0.0f, dot(R, toEye).x);
			//cosTh = dot(normal, normalize(toEye + toLight));
			cosTh = (2.0f - dot(B - B0, B - B0)) * 0.5f;

			float g = 1.0 - roughness;
			float g2 = g * g;
			float tmp = 1 - g2;
			tmp *= 0.5f / 3.14159265f;
			float tmp2 = tmp;
			tmp /= pow(1 + g2 - 2*g*cosTh, 1.5f);
			tmp2 /= pow(1 + g2 - 2*g*cosTh * 0.9, 1.5f);

			tmp -= tmp2;

			specular = intensity * tmp * saturate(dot( toLight, normal ).x);
			diffuse = intensity * tmp2 * saturate(dot( toLight, normal ).x);

			specular *= 3.14159265f * 2;
			diffuse *= 3.14159265f * 2;
		};
	};
	n3 = node {
		type = output;
	};

	connect n0 n2;
	connect n1.roughness n2.roughness;
	connect n2.diffuse n3.diffuse;
	connect n2.specular n3.specular;
	connect n2 n3;
};


ABC_approx = graph Reflectance {
	n0 = node {
		type = input;
	};
	n1 = node {
		type = data;
		params = (
			BRDF_A <type float>,
			BRDF_B <type float>,
			BRDF_C <type float>
		);
	};
	n2 = node {
		type = kernel;
		kernel = kernel Reflectance(
			in BRDF_A <type float>,
			in BRDF_B <type float>,
			in BRDF_C <type float>
		) {
			float lsize = 0.2f;

			float ldist = length(toLight);
			float sratio = min(1.0f, lsize/ldist);

			float3 vo = toEye;
			float3 B = vo - dot(vo, normal).xxx * normal;

			float BC = BRDF_B * BRDF_C;
			float BC2 = BC * BC;
			float CC = BRDF_C * BRDF_C;
			float TIS = (pow(1+BC2, 1-CC)-1) / (BC2*(1-CC));
			float AC = 1.0 / TIS;

			float3 toLightN = toLight / ldist;

			float3 R = reflect(-toLightN, normal);
			float3 vs = normalize(R);
			float3 B0 = vs - dot(vs, normal).x * normal;

			float x = distance(B, B0);
//			x /= sratio;
			x /= 0.08;
			float diff = AC / 50 / sratio;
			x /= max(0.0001f, min(1.0, dot(R, normal).x));

			float interp = smoothstep(7.5f, 7.99f, x);
			float xmeh = x;
			x = min(x, 7.99f);
			float x2 = x*x;
			float x3 = x*x2;
			float x4 = x*x3;
			float x5 = x*x4;
			float x6 = x*x5;
			float x7 = x*x6;
			float x8 = x*x7;
			float x9 = x*x8;
			float x10 = x*x9;
			float x11 = x*x10;
			float x12 = x*x11;

			float approx = (3.14159 + 61.5157 *x - 195.234 *x2 + 274.415 *x3 - 235.084 *x4 + 
   144.573 *x5 - 69.8671 *x6 + 25.2546 *x7 - 0.732579 *x8 - 
   0.316311 *x9 + 0.00283363 *x10)/(1 + 19.5811 *x - 61.942 *x2 + 
   91.3211 *x3 - 87.31 *x4 + 66.0931 *x5 - 45.7811 *x6 + 
   36.3551 *x7 - 33.8658 *x8 + 22.0028 *x9 - 2.13581 *x10 - 
   0.0967361 *x11 + 0.00127675 *x12);

			diff *= approx * (1.0f - interp) + interp * (1.43722f/(xmeh*xmeh));
			
			specular = intensity * diff;
			specular *= saturate(dot(normalize(toLight), normal).x + 0.15);
//			specular += intensity * saturate(dot(normalize(toLight), normal).x);

/+			diffuse = 0;
			specular = 0;+/
		};
	};
	n3 = node {
		type = output;
	};

	connect n0 n2;
	connect n1.BRDF_A n2.BRDF_A;
	connect n1.BRDF_B n2.BRDF_B;
	connect n1.BRDF_C n2.BRDF_C;
	connect n2.diffuse n3.diffuse;
	connect n2.specular n3.specular;
	connect n2 n3;
};


ABC_area = graph Reflectance {
	n0 = node {
		type = input;
	};
	n1 = node {
		type = data;
		params = (
			BRDF_A <type float>,
			BRDF_B <type float>,
			BRDF_C <type float>
		);
	};
	n2 = node {
		type = kernel;
		kernel = kernel Reflectance(
			in BRDF_A <type float>,
			in BRDF_B <type float>,
			in BRDF_C <type float>
		) {
			const bool sphere = true;

			float lsize = 0.94f;//1.8f * 1.00000001;

			if (!sphere) {
				float ldist = length(toLight);
				float sratio = lsize/ldist;
				lsize /= pow(1.0 - min(0.5f, sratio*sratio), 1.0/3);
			}

			float spec = 0.0f;
			float diff = 0.0f;
			float wtotal = 0.0f;

			float3 randSeed = normalize(toLight)*5120 + toEye*5120;
			randSeed *= sin(randSeed);

			float3 vo = toEye;
			float3 B = vo - dot(vo, normal).xxx * normal;

			float BC = BRDF_B * BRDF_C;
			float BC2 = BC * BC;
			float CC = BRDF_C * BRDF_C;
			float TIS = (pow(1+BC2, 1-CC)-1) / (BC2*(1-CC));
			float AC = 1.0 / TIS;

			float3 toLightN = normalize(toLight);

			int taps = min(50, max(1, 80.0f * lsize * lsize / dot(toLight, toLight)));
			for (int x = 0; x < taps; ++x) {
				float3 rand = frac(randSeed+x*float3(230.118323274, 5.3970233, 1.325398233123));
				float3 rpos;

				if (sphere) {
					float phi = rand.x * 2 * 3.14159265f;
					float u = (rand.y - .5f) * 2.f;
					float u2		= u*u;
					float rt		= sqrt(1.f - u2);
					rpos = float3(rt * cos(phi), u, rt * sin(phi)) * pow(rand.z, 1.0/3);
				} else {
					float theta = rand.x * 2 * 3.14159265f;
					float2 uv = float2(cos(theta), sin(theta)) * pow(rand.z, 2.0f/3.0f);
					float3 u = normalize(cross(toLightN, toLightN.x > 0.5 ? float3(0, 1, 0) : float3(1, 0, 0)));
					float3 v = cross(toLightN, u);
					u = cross(toLightN, v);
					rpos = u * uv.x + v * uv.y;
				}

				float3 L = normalize(toLight + rpos * lsize);
				float3 R = reflect(-L, normal);
				float3 vs = normalize(R);
				float3 B0 = vs - dot(vs, normal).x * normal;

				float tmp = dot(B - B0, B - B0);
				float tmp2 = tmp;
				tmp = pow(1+BC2*tmp, -CC);
				tmp2 = pow(1+BC2*(tmp2+0.3), -CC);
				tmp -= tmp2;

				const float fresnelR0 = 0.8f;
				float fresnel = pow(1.0f - saturate(dot(vo, normalize(L + vo)).x), 5.0f);
				fresnel *= (1.0f - fresnelR0);
				fresnel += fresnelR0;
				tmp *= fresnel;

				tmp *= saturate(dot(L, normal).x);
				tmp2 *= saturate(dot(L, normal).x);

				spec += tmp;
				diff += tmp2;
			}

			spec *= AC;
			spec /= taps;

			diff *= AC;
			diff /= taps;

			specular = intensity * spec;
//			diffuse = intensity * saturate(dot(normalize(toLight), normal).x);
//			specular = lsize * 0.04f;
			diffuse = intensity * diff;

/+			specular *= saturate(dot(normalize(toLight), normal).x + 0.15);
			diffuse *= saturate(dot(normalize(toLight), normal).x + 0.15);

			diffuse = 0;+/

/+			diffuse = 0;
			specular = 0;+/
		};
	};
	n3 = node {
		type = output;
	};

	connect n0 n2;
	connect n1.BRDF_A n2.BRDF_A;
	connect n1.BRDF_B n2.BRDF_B;
	connect n1.BRDF_C n2.BRDF_C;
	connect n2.diffuse n3.diffuse;
	connect n2.specular n3.specular;
	connect n2 n3;
};


ABC = graph Reflectance {
	n0 = node {
		type = input;
	};
	n1 = node {
		type = data;
		params = (
			BRDF_A <type float>,
			BRDF_B <type float>,
			BRDF_C <type float>
		);
	};
	n2 = node {
		type = kernel;
		kernel = kernel Reflectance(
			in BRDF_A <type float>,
			in BRDF_B <type float>,
			in BRDF_C <type float>
		) {
			float3 vi = normalize(toLight);
			float3 R = reflect(-vi, normal);
			float3 vo = toEye;
			float3 vs = R;
			float3 B = vo - dot(vo, normal).xxx * normal;
			float3 B0 = vs - dot(vs, normal).xxx * normal;

			float BC = BRDF_B * BRDF_C;
			float CC = BRDF_C * BRDF_C;
			float TIS = (pow(1+BC*BC, 1-CC)-1) / (BC*BC*(1-CC));
			float AC = 1.0 / TIS;

			float metalness = 0.9;

			float tmp = dot(B - B0, B - B0);
			float tmp2 = tmp;
			tmp = AC * pow(1+BC*BC*tmp, -CC);
//			tmp2 = AC * pow(1+BC*BC*tmp2+BRDF_C*BRDF_C*(1.0f / metalness - 1.0f), -CC);
			tmp2 = AC * pow(1+BC*BC*(tmp2+0.3), -CC);
			tmp -= tmp2;

			specular = intensity * tmp * saturate(dot( vi, normal ).x);
			diffuse = intensity * tmp2 * saturate(dot( vi, normal ).x);
		};
	};
	n3 = node {
		type = output;
	};

	connect n0 n2;
	connect n1.BRDF_A n2.BRDF_A;
	connect n1.BRDF_B n2.BRDF_B;
	connect n1.BRDF_C n2.BRDF_C;
	connect n2.diffuse n3.diffuse;
	connect n2.specular n3.specular;
	connect n2 n3;
};


ABg_h = graph Reflectance {
	n0 = node {
		type = input;
	};
	n1 = node {
		type = data;
		params = (
			BRDF_A <type float>,
			BRDF_B <type float>,
			BRDF_g <type float>
		);
	};
	n2 = node {
		type = kernel;
		kernel = kernel Reflectance(
			in BRDF_A <type float>,
			in BRDF_B <type float>,
			in BRDF_g <type float>
		) {
			/+diffuse = intensity;
			specular = 0;
			return;+/
		
			//BRDF_g *= pow(lightSize, 0.25);

			/+//BRDF_A *= pow(lightSize, 0.5);
			//BRDF_B *= pow(lightSize, 0.5);

			//intensity /= lightSize;

			float3 H = normalize(toLight + toEye);
			float3 B = H - dot(H, normal).xxx * normal;

			float tmp = dot(B, B);
			float tmp2 = tmp;
			tmp = pow(tmp, 0.5*BRDF_g);
			tmp = BRDF_A / (BRDF_B + tmp);

			tmp2 = pow(tmp2, 0.5*BRDF_g);
			tmp2 = BRDF_A / (BRDF_B + 0.3 + tmp2);+/

			float3 R = reflect(-toLight,normal);
			float3 vi = toLight;
			float3 vo = toEye;
			float3 vs = R;
			float3 B = vo - dot(vo, normal).xxx * normal;
			float3 B0 = vs - dot(vs, normal).xxx * normal;

			float tmp = dot(B - B0, B - B0);
			tmp = pow(tmp, 0.5*BRDF_g);
			tmp = BRDF_A / (BRDF_B + tmp);

			float tmp2 = dot(B - B0, B - B0);
			tmp2 = pow(tmp2, 0.5*BRDF_g);
			tmp2 = BRDF_A / (BRDF_B + 0.05 + tmp2);

			tmp -= tmp2;

			specular = 10 * intensity * tmp * saturate(dot( toLight, normal ).x);
			diffuse = 10 * intensity * tmp2 * saturate(dot( toLight, normal ).x);
		};
	};
	n3 = node {
		type = output;
	};

	connect n0 n2;
	connect n1.BRDF_A n2.BRDF_A;
	connect n1.BRDF_B n2.BRDF_B;
	connect n1.BRDF_g n2.BRDF_g;
	connect n2.diffuse n3.diffuse;
	connect n2.specular n3.specular;
	connect n2 n3;
};


ABg = graph Reflectance {
	n0 = node {
		type = input;
	};
	n1 = node {
		type = data;
		params = (
			BRDF_A <type float>,
			BRDF_B <type float>,
			BRDF_g <type float>
		);
	};
	n2 = node {
		type = kernel;
		kernel = kernel Reflectance(
			in BRDF_A <type float>,
			in BRDF_B <type float>,
			in BRDF_g <type float>
		) {
			float3 R = reflect(-toLight,normal);
			float3 vi = toLight;
			float3 vo = toEye;
			float3 vs = R;
			float3 B = vo - dot(vo, normal).xxx * normal;
			float3 B0 = vs - dot(vs, normal).xxx * normal;

			float tmp = dot(B - B0, B - B0);
			tmp = pow(tmp, 0.5*BRDF_g);
			float tmp2 = tmp;
			tmp = BRDF_A / (BRDF_B + tmp);
			tmp2 = BRDF_A / (BRDF_B + tmp2 * 1.0001);

			// Compute any aliases and intermediary values
			// -------------------------------------------
			float3 H	= normalize(toLight + toEye);
			float NdotL	= max(0.000f, dot(normal, toLight));
			float NdotH	= max(0.001f, dot(normal, H));
			float NdotV	= max(0.001f, dot(normal, toEye));
			float VdotH	= max(0.001f, dot(toEye, H));
		 
			// Evaluate the geometric term
			// ---------------------------

			float geoTerm; {
				float geo_numerator = 2.0f * NdotH;
			 
				float geo_b	= geo_numerator * NdotV / VdotH;
				float geo_c	= geo_numerator * NdotL / VdotH;
				geoTerm		= saturate((min(geo_b, geo_c)));
			}

			tmp -= tmp2;
			//tmp *= geoTerm;

			specular = 10 * intensity * tmp * saturate(dot( toLight, normal ).x);
			diffuse = 10 * intensity * tmp2 * saturate(dot( toLight, normal ).x);
		};
	};
	n3 = node {
		type = output;
	};

	connect n0 n2;
	connect n1.BRDF_A n2.BRDF_A;
	connect n1.BRDF_B n2.BRDF_B;
	connect n1.BRDF_g n2.BRDF_g;
	connect n2.diffuse n3.diffuse;
	connect n2.specular n3.specular;
	connect n2 n3;
};



AshikhminShirley = graph Reflectance {
	n0 = node {
		type = input;
	};
	n1 = node {
		type = data;
		params = (
			roughness <type float> = 0.2,
			fresnelR0 <type float> = 0.2
		);
	};
	n2 = node {
		type = kernel;
		kernel = kernel Reflectance(
			in roughness <type float>,
			in fresnelR0 <type float>
		) {
			float3 H	= normalize( toLight + toEye );
		 
			// Generate any useful aliases
			float VdotN	= saturate(dot( toEye, normal ).x);
			float LdotN	= saturate(dot( toLight, normal ).x);
			float HdotN	= saturate(dot( H, normal ).x);
			float HdotL	= saturate(dot( H, toLight ).x);
		 
			float specExp = 3.0f / roughness;	// from the Strauss model
		 
			// Compute the diffuse term
			float Pd = 28.0f / 23.0f;
			Pd *= (1.0f - pow(1.0f - (LdotN / 2.0f), 5.0f));
			Pd *= (1.0f - pow(1.0f - (VdotN / 2.0f), 5.0f));
			Pd *= (1.0f - fresnelR0);
		 
			float Ps_num = specExp + 1;
			Ps_num *= pow(HdotN, specExp);
		 
			float Ps_den = 8.0f;// * HdotL;
			const float k1n = LdotN;
			const float k2n = VdotN;
			// Ps_den *= max( k1n, k2n );	// regular A&S
			Ps_den *= k1n + k2n - k1n*k2n;	// modified per Michael's d-BRDF paper
			Ps_den += 0.001f;		// to avoid div by zero
		 
			float Ps = Ps_num / Ps_den;
			Ps *= ( fresnelR0 + (1.0f - fresnelR0) * pow( 1.0f - HdotL, 5.0f ) ).x;
			
			Pd *= LdotN;
			Ps *= LdotN;
			
			diffuse = intensity * Pd;
			specular = intensity * Ps;
		};
	};
	n3 = node {
		type = output;
	};

	connect n0 n2;
	connect n1.roughness n2.roughness;
	connect n1.fresnelR0 n2.fresnelR0;
	connect n2.diffuse n3.diffuse;
	connect n2.specular n3.specular;
	connect n2 n3;
};


CookTorrance = graph Reflectance {
	n0 = node {
		type = input;
	};
	n1 = node {
		type = data;
		params = (
			roughness <type float> = 0.2,
			fresnelR0 <type float> = 0.2
		);
	};
	n2 = node {
		type = kernel;
		kernel = kernel Reflectance(
			in roughness <type float>,
			in fresnelR0 <type float>
		) {
			toLight = normalize(toLight);

			// Compute any aliases and intermediary values
			// -------------------------------------------
			float3 H	= normalize(toLight + toEye);
			float NdotL	= max(0.000f, dot(normal, toLight));
			float NdotH	= max(0.001f, dot(normal, H));
			float NdotV	= max(0.001f, dot(normal, toEye));
			float VdotH	= max(0.001f, dot(toEye, H));
			float r_sq	= roughness * roughness;
		 
			// Evaluate the geometric term
			// ---------------------------

			float geoTerm; {
				float geo_numerator = 2.0f * NdotH;
			 
				float geo_b	= geo_numerator * NdotV / VdotH;
				float geo_c	= geo_numerator * NdotL / VdotH;
				geoTerm		= saturate((min(geo_b, geo_c)));
			} 
		 
			// Now evaluate the roughness term
			// -------------------------------
			
			float roughnessTerm; {
				float roughness_a = 1.0f / (4.0f * r_sq * pow(NdotH, 4));
				float roughness_b = NdotH * NdotH - 1.0f;
				float roughness_c = r_sq * NdotH * NdotH;

				float roughness_exp = roughness_b / roughness_c;

				// lolNaN
				roughnessTerm =
					roughness_exp > -85.0f
					? roughness_a * exp(roughness_exp)
					: 0.0f;
			}
		 
			// Next evaluate the Fresnel value
			// -------------------------------
			float fresnel = pow(1.0f - VdotH, 5.0f);
			fresnel *= (1.0f - fresnelR0);
			fresnel += fresnelR0;
		 
			// Put all the terms together to compute
			// the specular term in the equation
			// -------------------------------------
			float Rs = ( fresnel * geoTerm * roughnessTerm ) / NdotV;

			specular = intensity * Rs;
			diffuse = 0;//intensity * (NdotL + Rs);
		};
	};
	n3 = node {
		type = output;
	};

	connect n0 n2;
	connect n1.roughness n2.roughness;
	connect n1.fresnelR0 n2.fresnelR0;
	connect n2.diffuse n3.diffuse;
	connect n2.specular n3.specular;
	connect n2 n3;
};


BlinnPhong = graph Reflectance {
	n0 = node {
		type = input;
	};
	n1 = node {
		type = data;
		params = (
			specularPower <type float> = 20
		);
	};
	n2 = node {
		type = kernel;
		kernel = kernel Reflectance(
			in specularPower <type float>
		) {
			float NdotL = dot(normal, toLight).x;
			float3 H = normalize(toEye + toLight);
			diffuse = intensity * saturate(NdotL);
			specular = intensity * pow(saturate(dot(H, normal)), specularPower).xxxx;
			specular = NdotL > 0.0 ? specular : float4(0, 0, 0, 0);
		};
	};
	n3 = node {
		type = output;
	};

	connect n0 n2;
	connect n1.specularPower n2.specularPower;
	connect n2.diffuse n3.diffuse;
	connect n2.specular n3.specular;
	connect n2 n3;
};


Lambert = kernel Reflectance {
	float NdotL = dot(normal, toLight).x;
	diffuse = intensity * saturate(NdotL);
	specular = 0;
};


Uniform = kernel Reflectance {
	diffuse = intensity;
	specular = 0;
};


HalfLambert = kernel Reflectance {
	float NdotL = dot(normal, toLight).x;
	diffuse = NdotL * 0.5f + 0.5f;
	diffuse *= diffuse * intensity;
	specular = 0;
};
